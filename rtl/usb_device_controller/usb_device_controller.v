

//
//  USB 2.0 Serial data transfer entity
//
//  This entity implements a USB 2.0 device that carries a bidirectional
//  byte stream over the bus. It communicates with the host according to
//  the USB Communication Device Class, specifically the ACM (Abstract
//  Control Model) variant.
//
//  The low-level interface wires are labeled PHY_xxx && can be connected
//  to an UTMI-compliant PHY component. The PHY should be configured in 8-bit
//  mode.
//
//  The application interface supports simple byte-at-a-time sending &&
//  receiving. Three block RAMs are used to implement a receive buffer,
//  a transmission buffer && descriptor ROM.
//
//  The clk_i input must be the 60 MHz clock generated by the UTMI transceiver.
//  All application interface wires && PHY interface wires are
//  synchronized to the rising edge of clk_i, except for SUSPEND which has
//  an asynchronous reset.
//
//  Transmission:
//    * The entity asserts TXRDY when it is ready to send data.
//    * The application puts data on TXDAT && asserts TXVAL when it is
//      ready to send data.
//    * In each clock cycle in which TXRDY && TXVAL are both asserted,
//      the entity takes a byte from TXDAT && queues it for transmission.
//
//  Receiving:
//    * The application asserts RXRDY when it is ready to receive data.
//    * The entity puts data on RXDAT && asserts RXVAL when it has
//      data available. It will only do this in response to RXRDY.
//    * When RXVAL is high, the application must either accept a byte
//      from RXDAT && be ready for the next byte in the following cycle,
//      || it must deassert RXRDY to pause the receive queue.
//
//  At power on, && after reset_i, the device waits for 16 ms before
//  attaching to the USB bus. A high wire on ONLINE indicates that
//  the device has been fully configured by the host.
//
//  Bugs && limitations:
//    * The TEST_MODE feature (m&&atory for high speed devices) is
//      not implemented && returns an error condition to the host.
//    * The SEND_ENCAPSULATED_COMMAND && GET_ENCAPSULATED_RESPONSE comm&&s
//      (m&&atory CDC-ACM requests) are not supported but will return a
//      success condition to the host.
//    * The default control pipe does not verify requests from the host
//      as strictly as required by the st&&ard. As a result, invalid
//      requests from the host may sometimes appear to succeed when
//      they should have returned an error condition.
//
//  Implementation note:
//  At some point it may become useful to implement separate clock domains
//  for the application resp. PHY side of this entity, using the FIFO buffers
//  for clock domain crossing. As a first step, a distinction has been made
//  between application-side wires (prefixed with q_) && PHY-side wires
//  (prefixed with s_). Currently the corresponding wires from both sides
//  are simply wired together with asynchronous assignments. By replacing
//  these hardwired connections with carefully designed synchronization logic,
//  a separation of clock domains could be realized.
//

`include "static_macro_define.v"
`include "usb_device_controller_define.v"
//module usb_controller
module `getname(usb_device_controller,`module_name)
(
        // 60 MHz UTMI clock.
        input clk_i,

        // Synchronous reset; clear buffers && re-attach to the bus.
        input reset_i,

        // High for one clock when a reset wire is detected on the USB bus.
        // Note: do NOT wire this wire to reset_i externally.
        output usbrst_o,

        // High when the device is operating (|| suspended) in high speed mode.
        output highspeed_o,

        // High while the device is suspended.
        // Note: This wire is not synchronized to clk_i.
        // It may be used to asynchronously drive the UTMI SuspendM pin.
        output suspend_o,

        // High when the device is in the Configured state.
        output online_o,

        // High if a received byte is available on RXDAT.
        // Received data byte, valid if RXVAL is high.
        // High if the application is ready to receive the next byte.
        // Number of bytes currently available in receive buffer.

        // High if the application has data to send.
        // Data byte to send, must be valid if TXVAL is high.
        // High if the entity is ready to accept the next byte.
        input  [7:0]    txdat_i  ,
        input           txval_i  ,
        input  [11:0]   txdat_len_i,
        input  [3:0]    txiso_pid_i,
        input           txcork_i ,
        output          txpop_o  ,
        output          txact_o  ,
        output [7:0]    rxdat_o  ,
        output          rxval_o  ,
        input           rxrdy_i  ,
        output          rxact_o  ,
        output          rxpktval_o,
        output          txpktfin_o,
        output          setup_o,
        output [3:0]    endpt_o  ,
        output          sof_o    ,
        input  [7:0]    inf_alter_i,
        output [7:0]    inf_alter_o,
        output [7:0]    inf_sel_o,
        output          inf_set_o,


        // Number of free byte positions currently available in transmit buffer.
        output [15:0]   descrom_raddr_o,
        output [7:0]    desc_index_o,
        output [7:0]    desc_type_o,
        input  [7:0]    descrom_rdata_i,


        // Temporarily suppress transmissions at the outgoing endpoint.
        // This gives the application an oppertunity to fill the transmit
        // buffer in order to blast data efficiently in big chunks.
        // Start Address of device descriptor
        input  [15:0]    desc_dev_addr_i,
        // Length of device descriptor
        input  [15:0]    desc_dev_len_i,
        // Start Address of device qualifier
        input  [15:0]    desc_qual_addr_i,
        // Length of device qualifier
        input  [15:0]    desc_qual_len_i,
        // Start Address of device full speed configuration
        input  [15:0]    desc_fscfg_addr_i,
        // Length of device full speed configuration
        input  [15:0]    desc_fscfg_len_i,
        // Start Address of device high speed configuration
        input  [15:0]    desc_hscfg_addr_i,
        // Length of device high speed configuration
        input  [15:0]    desc_hscfg_len_i,
        // Start Address of device other speed configuration
        input  [15:0]    desc_oscfg_addr_i,
        // Start Address of device string descriptor
        input  [15:0]    desc_strlang_addr_i,
        // Start Address of device verdor string
        input  [15:0]    desc_strvendor_addr_i,
        // Length of device verdor string
        input  [15:0]    desc_strvendor_len_i,
        // Start Address of device product string
        input  [15:0]    desc_strproduct_addr_i,
        // Length of device Verdor string
        input  [15:0]    desc_strproduct_len_i,
        // Start Address of device serial string
        input  [15:0]    desc_strserial_addr_i,
        // Length of device verdor string
        input  [15:0]    desc_strserial_len_i,
        // High when device decriptor have string descriptor
        input           desc_have_strings_i,
        // Start Address of device HID report
        input  [15:0]    desc_hidrpt_addr_i,
        // Length of device HID report
        input  [15:0]    desc_hidrpt_len_i,

        output [7:0] utmi_dataout_o   ,
        output       utmi_txvalid_o   ,
        input        utmi_txready_i   ,
        input  [7:0] utmi_datain_i    ,
        input        utmi_rxactive_i  ,
        input        utmi_rxvalid_i   ,
        input        utmi_rxerror_i   ,
        input  [1:0] utmi_linestate_i ,
        output [1:0] utmi_opmode_o    ,
        output [1:0] utmi_xcvrselect_o,
        output       utmi_termselect_o,
        output       utmi_reset_o     ,

        output       ack_timeout_o    ,
        output       ack_received_o   , 
        output       ack_bad_packet_o
        ,output wire [3:0] transact_state_o
        ,output wire [3:0] crc_dbg_dataout_o
        ,input wire clk_120
        ,output wire stuck_in_2nd_or_3rd_state_o
);


    localparam ENDPT_NUM = 15;
    // Maximum packet size according to protocol.
    localparam MAX_FSPACKET_SIZE = 1023;
    localparam MAX_HSPACKET_SIZE = 1024;
    // State machine
    localparam ST_IDLE= 0;
    localparam ST_STALL= 1;
    localparam ST_NAK= 2;
    localparam ST_INSTART= 3;
    localparam ST_INSEND= 4;
    localparam ST_INDONE= 5;
    localparam ST_OUTRECV= 6;
    localparam ST_OUTNAK = 7;
    localparam ST_SETUP= 8;

    // TX buffer
    //reg [7:0] txbuf_rdat;
    wire [7:0] txbuf_rdat;

    // Interface to usb_init
    wire       usbi_usbrst;
    wire       usbi_highspeed;
    wire       usbi_suspend;

    // Interface to usb_packet
    wire       usbp_chirpk;
    wire       usbp_rxact;
    wire       usbp_rxrdy;
    wire       usbp_rxfin;
    wire [7:0] usbp_rxdat;
    wire       usbp_txact;
    wire       usbp_txrdy;
    wire [7:0] usbp_txdat;

    // Interface to usb_transact
    wire       usbt_in;
    wire       usbt_out;
    wire       usbt_setup;
    wire       usbt_ping;
    wire       usbt_fin;
    wire [3:0] usbt_endpt;
    wire       usbt_nak;
    wire       usbt_stall;
    wire       usbt_nyet;
    wire       usbt_send;
    wire       usbt_isync;
    wire       usbt_osync;
    wire       usbt_rxrdy;
    wire [7:0] usbt_rxdat;
    reg  [1:0] usbt_type;
    wire       usbt_txrdy;
    wire [7:0] usbt_txdat;

    // Interface to usb_control
    wire [6:0] usbc_addr;
    wire       usbc_confd;
    wire [1:ENDPT_NUM] usbc_clr_in;
    wire [1:ENDPT_NUM] usbc_clr_out;
    wire [1:ENDPT_NUM] usbc_sethlt_in;
    wire [1:ENDPT_NUM] usbc_sethlt_out;
    wire       usbc_dscbusy;
    wire       usbc_dscrd;
    wire [7:0] usbc_dsctyp;
    wire [7:0] usbc_dscinx;
    wire [15:0] usbc_dscoff;
    reg  [15:0] descrom_raddr;
    reg  [15:0] descrom_start;
    reg  [15:0] usbc_dsclen;
    wire       usbc_selfpowered;
    wire       usbc_in;
    wire       usbc_out;
    wire       usbc_setup;
    wire       usbc_ping;
    wire       usbc_nak;
    wire       usbc_stall;
    wire       usbc_nyet;
    wire       usbc_send;
    wire       usbc_isync;
    wire [7:0] usbc_txdat;

    reg  [3:0] cur_state;
    reg  [3:0] next_state;
    // Endpoint administration (PHY side).
    reg [1:ENDPT_NUM] isync = 0;
    reg [1:ENDPT_NUM] osync = 0;
    reg [1:ENDPT_NUM] halt_in  = 0 ;
    reg [1:ENDPT_NUM] halt_out = 0 ;
    reg [11 : 0] s_txbuf_stop;
    reg [11 : 0] s_bufptr;
    reg          s_isync;
    reg          s_osync;
    reg          s_halt_in;
    reg          s_halt_out;
    reg          s_endpt_rxrdy;
    reg          s_endpt_txcork;
    reg          s_endpt_tx_en;
    reg          s_nyet;
    // Control wires (PHY side).
    wire         s_reset;
    // Status wires (application side).
    wire         q_usbrst;
    wire         q_online;
    wire         q_highspeed;

    //Test Packet
    //
    `ifdef HSSUPPORT
    wire       test_dval;
    wire       test_en_dly;
    wire [7:0] test_data;
    wire [7:0] usbc_testmode;
    wire       usbc_test_en;
    wire [1:0] usbi_opmode;
    wire [7:0] usbp_dataout_o;
    wire       usbp_txvalid_o;
    wire       test_nak_en;
    //testmode: 01->Test_J  02->Test_K
    assign test_nak_en = usbc_test_en&(usbc_testmode == 8'h03);
    assign utmi_opmode_o = (!test_en_dly) ? usbi_opmode :
                           ((usbc_testmode == 8'h01) | (usbc_testmode == 8'h02)) ? 2'b10 : usbi_opmode;
    assign utmi_dataout_o = (!test_en_dly) ?  usbp_dataout_o :
                            (usbc_testmode == 8'h01) ? 8'hFF :
                            (usbc_testmode == 8'h02) ? 8'h00 :
                            (usbc_testmode == 8'h04) ? test_data : usbp_dataout_o;
    assign utmi_txvalid_o = (!test_en_dly) ? usbp_txvalid_o :
                            (usbc_testmode == 8'h01) ? 1'b1 :
                            (usbc_testmode == 8'h02) ? 1'b1 :
                            (usbc_testmode == 8'h04) ? test_dval  : usbp_txvalid_o;
    //test_packet test_packet
    `getname(test_packet,`module_name) test_packet_inst
    (
         .clk_i         (clk_i           )//clock
        ,.reset_i       (s_reset         )//reset
        ,.test_en_i     (usbc_test_en    )//
        ,.test_mode_i   (usbc_testmode   )//
        ,.test_en_dly_o (test_en_dly     )//
        ,.tx_rdy_i      (utmi_txready_i  )//
        ,.test_dval_o   (test_dval       )//
        ,.test_data_o   (test_data       )//
    );
    `else
    wire [1:0] usbi_opmode;
    wire [7:0] usbp_dataout_o;
    wire       usbp_txvalid_o;
    assign utmi_opmode_o  = usbi_opmode;
    assign utmi_dataout_o = usbp_dataout_o;
    assign utmi_txvalid_o = usbp_txvalid_o;
    `endif

    // Bus reset logic
    //usb_init #(
    `getname(usb_init,`module_name)
//    #( .HSSUPPORT       (`HSSUPPORT) )
    u_usb_init (
            .CLK             (clk_i            ),
            .RESET           (s_reset          ),
    `ifdef HSSUPPORT
            .I_USB_TEST_EN   (usbc_test_en     ),
    `endif
            .I_USBRST        (usbi_usbrst      ),
            .I_HIGHSPEED     (usbi_highspeed   ),
            .I_SUSPEND       (usbi_suspend     ),
            .P_CHIRPK        (usbp_chirpk      ),
            .PHY_RESET       (utmi_reset_o     ),
            .PHY_LINESTATE   (utmi_linestate_i ),
            .PHY_OPMODE      (usbi_opmode      ),
            .PHY_XCVRSELECT  (utmi_xcvrselect_o),
            .PHY_TERMSELECT  (utmi_termselect_o));

    // Packet level logic
    //usb_packet  u_usb_packet(
    `getname(usb_packet,`module_name) u_usb_packet(
            .CLK             (clk_i         ),
            .RESET           (usbi_usbrst   ),
            .P_CHIRPK        (usbp_chirpk   ),
            .P_RXACT         (usbp_rxact    ),
            .P_RXRDY         (usbp_rxrdy    ),
            .P_RXFIN         (usbp_rxfin    ),
            .P_RXDAT         (usbp_rxdat    ),
            .P_TXACT         (usbp_txact    ),
            .P_TXRDY         (usbp_txrdy    ),
            .P_TXDAT         (usbp_txdat    ),
            .PHY_DATAOUT     (usbp_dataout_o ),
            .PHY_TXVALID     (usbp_txvalid_o  ),
            .PHY_TXREADY     (utmi_txready_i  ),
            .PHY_DATAIN      (utmi_datain_i  ),
            .PHY_RXACTIVE    (utmi_rxactive_i),
            .PHY_RXVALID     (utmi_rxvalid_i ),
            .PHY_RXERROR     (utmi_rxerror_i )
            ,.clk_120 (clk_120) 
            ,.crc_dbg_dataout_o ()//(crc_dbg_dataout_o) 
        );
    // Transaction level logic
    //usb_transact #(
    `getname(usb_transact,`module_name)
   // #( .HSSUPPORT       (`HSSUPPORT) )
        usb_transact_inst(
            .CLK             (clk_i         ),
            .RESET           (usbi_usbrst   ),
        `ifdef HSSUPPORT
            .C_TESTNAK       (test_nak_en   ),
        `endif
            .T_IN            (usbt_in       ),
            .T_OUT           (usbt_out      ),
            .T_SOF           (sof_o         ),
            .T_SETUP         (usbt_setup    ),
            .T_PING          (usbt_ping     ),
            .T_FIN           (usbt_fin      ),
            .T_ADDR          (usbc_addr     ),
            .T_ENDPT         (usbt_endpt    ),
            .T_NAK           (usbt_nak      ),
            .T_STALL         (usbt_stall    ),
            .T_NYET          (usbt_nyet     ),
            .T_SEND          (usbt_send     ),
            .T_ISYNC         (usbt_isync    ),
            .T_OSYNC         (usbt_osync    ),
            .T_RXRDY         (usbt_rxrdy    ),
            .T_RXDAT         (usbt_rxdat    ),
            .T_TYPE          (usbt_type     ),
            .T_PID_DATA      (txiso_pid_i   ),
            .T_TXRDY         (usbt_txrdy    ),
            .T_TXDAT         (usbt_txdat    ),
            .I_HIGHSPEED     (usbi_highspeed),
            .P_RXACT         (usbp_rxact    ),
            .P_RXRDY         (usbp_rxrdy    ),
            .P_RXFIN         (usbp_rxfin    ),
            .P_RXDAT         (usbp_rxdat    ),
            .P_TXACT         (usbp_txact    ),
            .P_TXRDY         (usbp_txrdy    ),
            .P_TXDAT         (usbp_txdat    ),
            .ack_timeout_o   (ack_timeout_o ),
            .ack_received_o  (ack_received_o  ),
            .ack_bad_packet_o(ack_bad_packet_o)
            ,.transact_state_o (transact_state_o)
            ,.stuck_in_2nd_or_3rd_state_o (stuck_in_2nd_or_3rd_state_o)
    );

    // Default control endpoint
    //usb_control #(
    `getname(usb_control,`module_name) #(
        .NENDPT              (ENDPT_NUM) )
        usb_control_inst (
            .CLK             (clk_i           ),
            .RESET           (usbi_usbrst     ),
        `ifdef HSSUPPORT
            .C_TESTMODE      (usbc_testmode   ),
            .C_TEST_EN       (usbc_test_en    ),
        `endif
            .C_ADDR          (usbc_addr       ),
            .C_CONFD         (usbc_confd      ),
            .C_CLRIN         (usbc_clr_in     ),
            .C_CLROUT        (usbc_clr_out    ),
            .C_HLTIN         (halt_in         ),
            .C_HLTOUT        (halt_out        ),
            .C_SHLTIN        (usbc_sethlt_in  ),
            .C_SHLTOUT       (usbc_sethlt_out ),

            .C_INTERFACE_ALTER_I (inf_alter_i),
            .C_INTERFACE_ALTER_O (inf_alter_o),
            .C_INTERFACE         (inf_sel_o  ),
            .C_INTERFACE_UPDATE  (inf_set_o  ),

            .C_DSCBUSY       (usbc_dscbusy    ),
            .C_DSCRD         (usbc_dscrd      ),
            .C_DSCTYP        (usbc_dsctyp     ),
            .C_DSCINX        (usbc_dscinx     ),
            .C_DSCOFF        (usbc_dscoff     ),
            .C_DSCLEN        (usbc_dsclen     ),
            .C_SELFPOWERED   (usbc_selfpowered),

            .T_IN            (usbc_in         ),
            .T_OUT           (usbc_out        ),
            .T_SETUP         (usbc_setup      ),
            .T_PING          (usbc_ping       ),
            .T_FIN           (usbt_fin        ),
            .T_NAK           (usbc_nak        ),
            .T_STALL         (usbc_stall      ),
            .T_NYET          (usbc_nyet       ),
            .T_SEND          (usbc_send       ),
            .T_ISYNC         (usbc_isync      ),
            .T_OSYNC         (usbt_osync      ),
            .T_RXRDY         (usbt_rxrdy      ),
            .T_RXDAT         (usbt_rxdat      ),
            .T_TXRDY         (usbt_txrdy      ),
            .T_TXDAT         (usbc_txdat      ));

    // Assign usb_serial output wires.
    assign usbrst_o      = q_usbrst;
    assign highspeed_o   = q_highspeed;
    assign suspend_o     = usbi_suspend;
    assign online_o      = q_online;

    // Assign usb_control input wires
    assign usbc_in     = (usbt_endpt == 4'b0000) ? usbt_in    : 0;
    assign usbc_out    = (usbt_endpt == 4'b0000) ? usbt_out   : 0;
    assign usbc_setup  = (usbt_endpt == 4'b0000) ? usbt_setup : 0;
    assign usbc_ping   = (usbt_endpt == 4'b0000) ? usbt_ping  : 0;
    `ifdef SELFPOWERED
        assign usbc_selfpowered = 1'b1;
    `else
        assign usbc_selfpowered = 1'b0;
    `endif


    // Assign usb_transact input lines
    `ifdef HSSUPPORT
    assign usbt_nak    = test_nak_en ? 1'b1 : (usbt_endpt == 4'b0000) ? usbc_nak : (next_state == ST_NAK) ? 1 : 0;
    assign usbt_stall  = test_nak_en ? 1'b0 : (usbt_endpt == 4'b0000) ? usbc_stall : (next_state == ST_STALL) ? 1 : 0;
    `else
    assign usbt_nak    = (usbt_endpt == 4'b0000) ? usbc_nak : (next_state == ST_NAK) ? 1 : 0;
    assign usbt_stall  = (usbt_endpt == 4'b0000) ? usbc_stall : (next_state == ST_STALL) ? 1 : 0;
    `endif
    assign usbt_nyet   = (usbt_endpt == 4'b0000) ? usbc_nyet  : s_nyet;
    assign usbt_send   = (usbt_endpt == 4'b0000) ? txval_i|usbc_send  : (cur_state == ST_INSEND) ? 1 : 0;
    //assign usbt_isync  = (usbt_endpt == 4'b0000) ? usbc_isync : s_isync;
    assign usbt_isync  = (usbt_endpt == 4'b0000) ? endpt0_isync : s_isync;
    assign usbt_txdat  = (usbt_endpt == 4'b0000 && usbc_dscbusy == 0) ? (txval_i ? txbuf_rdat : usbc_txdat) : (usbt_endpt == 4'b0000) ? descrom_rdata_i : txbuf_rdat;

    // Connection between PHY-side && application-side wires.
    // This could be a good place to insert clock domain crossing.
    assign s_reset     = reset_i;
    assign q_online    = usbc_confd;
    assign q_usbrst    = usbi_usbrst;
    assign q_highspeed = usbi_highspeed;




    // Determine the maximum packet size we can transmit.
    wire [ENDPT_NUM:0] endpt_in;
    wire [ENDPT_NUM:0] endpt_out;
    // Determine if there is room for another packet in the RX buffer.
    // We need room for the largest possible incoming packet, plus
    // two CRC bytes.
    // Currently receiving a packet; compare against the temporary
    // tail pointer to decide NYET vs ACK.
    // Not receiving a packet (|| NYET not supported);
    // compare against the tail pointer to decide NAK vs ACK.
    genvar i;
    generate
        for(i=1;i<=ENDPT_NUM;i=i+1) begin : halt_sync
            always @(posedge clk_i) begin
                if (s_reset == 1) begin
                    halt_in[i] <= 0;
                    halt_out[i] <= 0;
                end
                else if (usbi_usbrst == 1) begin
                    halt_in[i] <= 0;
                    halt_out[i] <= 0;
                end
                else begin
                    halt_in[i] <= (halt_in[i] || usbc_sethlt_in[i]) && (~usbc_clr_in[i]);
                    halt_out[i] <= (halt_out[i] || usbc_sethlt_out[i]) && (~usbc_clr_out[i]);
                end
            end
            always @(posedge clk_i) begin
                if (s_reset == 1) begin
                    isync[i] <= 0;
                    osync[i] <= 0;
                end
                else if (usbi_usbrst == 1) begin
                    isync[i] <= 0;
                    osync[i] <= 0;
                end
                else if (cur_state == ST_IDLE) begin
                    isync[i] <= isync[i] && (~usbc_clr_in[i]);
                    osync[i] <= osync[i] && (~usbc_clr_out[i]);
                end
                else if (cur_state == ST_INDONE) begin
                    if ( (usbt_endpt == i) ) begin
                        if (usbt_type == 2'd1) begin
                            isync[i] <= 1'b0;
                        end
                        else if (usbt_fin == 1) begin
                            isync[i] <= ~isync[i];
                        end
                    end
                end
                else if (cur_state == ST_OUTRECV) begin
                    if ( (usbt_endpt == i) && (usbt_fin == 1) && (usbt_osync == osync[i])) begin
                        // Good packet received; discard CRC bytes
                        osync[i] <= ~osync[i];
                    end
                end
            end
        end
    endgenerate

    reg endpt0_isync;
    reg endpt0_osync;
    always @(posedge clk_i) begin
        if (s_reset == 1) begin
            endpt0_isync <= 1'b1;
            endpt0_osync <= 1'b1;
        end
        else if (usbi_usbrst == 1) begin
            endpt0_isync <= 1'b1;
            endpt0_osync <= 1'b1;
        end
        else if (cur_state == ST_SETUP) begin
            endpt0_isync <= 1'b1;
            endpt0_osync <= 1'b1;
        end
        else if (cur_state == ST_INDONE) begin
            if (usbt_endpt == 4'b0000) begin
                if (usbt_fin == 1) begin
                    endpt0_isync <= ~endpt0_isync;
                end
            end
        end
        else if (cur_state == ST_OUTRECV) begin
            if ( (usbt_endpt == 4'b0000) && (usbt_fin == 1) && (usbt_osync == endpt0_osync)) begin
                // Good packet received; discard CRC bytes
                endpt0_osync <= ~endpt0_osync;
            end
        end
    end


    assign crc_dbg_dataout_o[0] = endpt0_isync; 
    assign crc_dbg_dataout_o[1] = endpt0_osync; 
    assign crc_dbg_dataout_o[2] = isync[1]; 
    assign crc_dbg_dataout_o[3] = osync[1]; 


    always @(posedge clk_i) begin
        if (s_reset == 1) begin
            s_endpt_rxrdy  <= 1'b0;
            s_endpt_txcork <= 1'b0;
            s_halt_out     <= 1'b0;
            s_halt_in      <= 1'b0;
            s_osync        <= 1'b0;
            s_isync        <= 1'b0;
        end
        else begin
            s_endpt_rxrdy  <= rxrdy_i;
            `ifdef HSSUPPORT
                if (test_nak_en) begin //Test_SE0_NAK
                    s_endpt_txcork <= 1'b1;
                end
                else begin
                    s_endpt_txcork <= txcork_i;
                end
            `else
                s_endpt_txcork <= txcork_i;
            `endif
            s_halt_out     <= halt_out[usbt_endpt];
            s_halt_in      <= halt_in[usbt_endpt];
            s_osync        <= osync[usbt_endpt];
            s_isync        <= isync[usbt_endpt];
        end
    end

    always @(posedge clk_i) begin
        if (s_reset == 1) begin
            s_txbuf_stop   <= 12'd32;
        end
        else begin
            `ifdef HSSUPPORT
                s_txbuf_stop <= (txdat_len_i > MAX_HSPACKET_SIZE ? MAX_HSPACKET_SIZE : txdat_len_i);
            `else
                s_txbuf_stop <= (txdat_len_i > MAX_FSPACKET_SIZE ? MAX_FSPACKET_SIZE : txdat_len_i);
            `endif
            //if (`HSSUPPORT) begin
            //    s_txbuf_stop <= (txdat_len_i > MAX_HSPACKET_SIZE ? MAX_HSPACKET_SIZE : txdat_len_i);
            //end
            //else begin
            //    s_txbuf_stop <= (txdat_len_i > MAX_FSPACKET_SIZE ? MAX_FSPACKET_SIZE : txdat_len_i);
            //end
        end
    end
    always @(posedge clk_i) begin
        if (s_reset == 1) begin
            usbt_type <= 2'd0;
        end
        else begin
            if (usbt_in) begin
                case (usbt_endpt)
                    4'd0  : usbt_type <= 2'b00;
                    4'd1  : usbt_type <= `ENDPT1_IN_T_TYPE;
                    4'd2  : usbt_type <= `ENDPT2_IN_T_TYPE;
                    4'd3  : usbt_type <= `ENDPT3_IN_T_TYPE;
                    4'd4  : usbt_type <= `ENDPT4_IN_T_TYPE;
                    4'd5  : usbt_type <= `ENDPT5_IN_T_TYPE;
                    4'd6  : usbt_type <= `ENDPT6_IN_T_TYPE;
                    4'd7  : usbt_type <= `ENDPT7_IN_T_TYPE;
                    4'd8  : usbt_type <= `ENDPT8_IN_T_TYPE;
                    4'd9  : usbt_type <= `ENDPT9_IN_T_TYPE;
                    4'd10 : usbt_type <= `ENDPT10_IN_T_TYPE;
                    4'd11 : usbt_type <= `ENDPT11_IN_T_TYPE;
                    4'd12 : usbt_type <= `ENDPT12_IN_T_TYPE;
                    4'd13 : usbt_type <= `ENDPT13_IN_T_TYPE;
                    4'd14 : usbt_type <= `ENDPT14_IN_T_TYPE;
                    4'd15 : usbt_type <= `ENDPT15_IN_T_TYPE;
                endcase
            end
            else if (usbt_out) begin
                case (usbt_endpt)
                    4'd0  : usbt_type <= 2'b00;
                    4'd1  : usbt_type <= `ENDPT1_OUT_T_TYPE;
                    4'd2  : usbt_type <= `ENDPT2_OUT_T_TYPE;
                    4'd3  : usbt_type <= `ENDPT3_OUT_T_TYPE;
                    4'd4  : usbt_type <= `ENDPT4_OUT_T_TYPE;
                    4'd5  : usbt_type <= `ENDPT5_OUT_T_TYPE;
                    4'd6  : usbt_type <= `ENDPT6_OUT_T_TYPE;
                    4'd7  : usbt_type <= `ENDPT7_OUT_T_TYPE;
                    4'd8  : usbt_type <= `ENDPT8_OUT_T_TYPE;
                    4'd9  : usbt_type <= `ENDPT9_OUT_T_TYPE;
                    4'd10 : usbt_type <= `ENDPT10_OUT_T_TYPE;
                    4'd11 : usbt_type <= `ENDPT11_OUT_T_TYPE;
                    4'd12 : usbt_type <= `ENDPT12_OUT_T_TYPE;
                    4'd13 : usbt_type <= `ENDPT13_OUT_T_TYPE;
                    4'd14 : usbt_type <= `ENDPT14_OUT_T_TYPE;
                    4'd15 : usbt_type <= `ENDPT15_OUT_T_TYPE;
                endcase
            end
            else begin
                case (usbt_endpt)
                    4'd0  : usbt_type <= 2'b00;
                    4'd1  : usbt_type <= `ENDPT1_OUT_T_TYPE;
                    4'd2  : usbt_type <= `ENDPT2_OUT_T_TYPE;
                    4'd3  : usbt_type <= `ENDPT3_OUT_T_TYPE;
                    4'd4  : usbt_type <= `ENDPT4_OUT_T_TYPE;
                    4'd5  : usbt_type <= `ENDPT5_OUT_T_TYPE;
                    4'd6  : usbt_type <= `ENDPT6_OUT_T_TYPE;
                    4'd7  : usbt_type <= `ENDPT7_OUT_T_TYPE;
                    4'd8  : usbt_type <= `ENDPT8_OUT_T_TYPE;
                    4'd9  : usbt_type <= `ENDPT9_OUT_T_TYPE;
                    4'd10 : usbt_type <= `ENDPT10_OUT_T_TYPE;
                    4'd11 : usbt_type <= `ENDPT11_OUT_T_TYPE;
                    4'd12 : usbt_type <= `ENDPT12_OUT_T_TYPE;
                    4'd13 : usbt_type <= `ENDPT13_OUT_T_TYPE;
                    4'd14 : usbt_type <= `ENDPT14_OUT_T_TYPE;
                    4'd15 : usbt_type <= `ENDPT15_OUT_T_TYPE;
                endcase
            end
        end
    end

    generate
       for(i=0;i<=ENDPT_NUM;i=i+1) begin : set_endpt
            //assign endpt_in[i]  = (usbt_endpt == i)&&(iendpt_en[i]);
            //assign endpt_out[i] = (usbt_endpt == i)&&(oendpt_en[i]);
            assign endpt_in[i]  = (usbt_endpt == i);
            assign endpt_out[i] = (usbt_endpt == i);
        end
    endgenerate
    // Main PHY-side synchronous always @.
    always @(posedge clk_i) begin
        if (s_reset == 1) begin
            cur_state <= ST_IDLE;
        end
        else begin
            cur_state <= next_state;
        end
    end
    always @(*) begin
        // State machine
        if (s_reset == 1) begin
            next_state = ST_IDLE;
        end
        else if (usbi_usbrst == 1) begin
            next_state  = ST_IDLE;
        end
        else begin
            case (cur_state)
                ST_IDLE : begin
                    // Idle; wait for a transaction
                    if ((usbt_out == 1)&&(|endpt_out))begin
                        // Start of OUT transaction
                        if (s_halt_out == 1) begin
                            // Endpoint halted
                            next_state = ST_STALL;
                        end
                        else if (s_endpt_rxrdy == 1) begin
                            // Prepare to receive data
                            next_state = ST_OUTRECV;
                        end
                        else begin
                            // We have no room to store a new packet
                            next_state = ST_OUTNAK;
                        end
                    end
                    else if (usbt_setup == 1)begin
                        next_state = ST_SETUP;
                    end
                    else if ((usbt_in == 1)&&(|endpt_in)) begin
                        // Start of IN transaction
                        if (s_halt_in == 1)
                            // Endpoint halted
                            next_state = ST_STALL;
                        else if (s_endpt_txcork == 0) begin
                            // Prepare to send data
                            next_state = ST_INSTART;
                        end else begin
                            // We have no data to send
                            next_state = ST_NAK;
                        end
                    end
                    `ifdef HSSUPPORT
                        else if ((usbt_ping == 1) && (|endpt_out)) begin
                             // Start of PING transaction
                            if (s_endpt_rxrdy == 1) begin
                                // There is room in the RX buffer for another packet; do nothing (ACK).
                                next_state = ST_IDLE;
                            end
                            else begin
                                // There is no room in the RX buffer; respond with NAK.
                                next_state = ST_NAK;
                            end
                        end
                    `endif
                    else begin
                        next_state = ST_IDLE;
                    end
                end
                ST_STALL :
                    // Wait for end of transaction
                    if ((usbt_in == 0) && (usbt_out == 0) && (usbt_ping == 0)) begin
                        next_state = ST_IDLE;
                    end
                    else begin
                        next_state = ST_STALL;
                    end
                ST_NAK :
                    // Wait for end of transaction
                    if ((usbt_in == 0) && (usbt_out == 0) && (usbt_ping == 0)) begin
                        next_state = ST_IDLE;
                    end
                    else begin
                        next_state = ST_NAK;
                    end
                ST_INSTART : begin
                    // Prepare to send data; read first byte from memory.
                    if (usbt_in == 0)
                        // Transaction canceled.
                        next_state = ST_IDLE;
                    else if (s_bufptr == s_txbuf_stop) begin
                        // The TX buffer is empty, || a previous empty packet
                        // is unacknowledged, || the TX buffer is corked;
                        // must send an empty packet.
                        next_state = ST_INDONE;
                    end
                    else begin
                        // Send a non-empty packet.
                        next_state = ST_INSEND;
                    end
                end
                ST_INSEND :
                    // Sending data
                    if (usbt_in == 0) begin
                        // Transaction canceled.
                        next_state = ST_IDLE;
                    end
                     else if ( usbt_txrdy == 1) begin
                        // Need to provide the next data byte;
                        // stop when we reach the end of the TX buffer;
                        // stop when we reach the packet size limit.
                        if (s_bufptr >= s_txbuf_stop) begin
                            // No more bytes
                            next_state = ST_INDONE;
                        end
                        else begin
                            next_state = ST_INSEND;
                        end
                    end
                    else begin
                        next_state = ST_INSEND;
                    end
                ST_INDONE : begin
                    // Done sending packet; wait for ACK.
                    if (usbt_in == 0) begin
                        // No acknowledgement
                        // Set limit for next packet to the same point
                        // Done
                        next_state = ST_IDLE;
                    end
                    else if ( usbt_fin == 1) begin
                        // Got acknowledgement
                        next_state = ST_IDLE;
                    end
                    else begin
                        next_state = ST_INDONE;
                    end
                end
                ST_SETUP :
                    if (usbt_setup == 0) begin
                        next_state = ST_IDLE;
                    end
                    else begin
                        next_state = ST_SETUP;
                    end
                ST_OUTRECV :
                    // Receiving data
                    if (usbt_out == 0) begin
                        // Transaction ended.
                        // If the transaction was succesful, usbt_fin has been
                        // asserted in the previous cycle && has triggered
                        // an update of s_rxbuf_head.
                        next_state = ST_IDLE;
                    end
                    else begin
                        next_state = ST_OUTRECV;
                    end
                ST_OUTNAK :
                    // Receiving data while we don't have room to store it
                    if (usbt_out == 0) begin
                        // End of transaction
                        next_state = ST_IDLE;
                    end
                    else if (usbt_rxrdy == 1) begin
                        // This is a new (non-duplicate) packet, but we can
                        // not store it; so respond with NAK.
                        if (usbt_type == 1'b1) begin
                            next_state = ST_IDLE;
                        end
                        else if (usbt_osync == s_osync) begin
                            next_state = ST_NAK;
                        end
                        else begin
                            next_state = ST_OUTNAK;
                        end
                    end
                    else begin
                        next_state = ST_OUTNAK;
                    end
                default: next_state  = ST_IDLE;
            endcase
        end
    end
    always @(posedge clk_i) begin
        // State machine
        if (s_reset == 1) begin
            s_bufptr <= 0;//to_unsigned(0, BUFPTR_SIZE);
            s_endpt_tx_en <= 1'b0;
            s_nyet <= 0;
        end
        else if (usbi_usbrst == 1) begin
            s_bufptr <= 0;//to_unsigned(0, BUFPTR_SIZE);
            s_endpt_tx_en <= 1'b0;
            s_nyet <= 0;
        end
        else begin
            case (cur_state)
                ST_IDLE : begin
                    // Idle; wait for a transaction
                    s_bufptr <= 0;
                    s_nyet <= 0;
                    s_endpt_tx_en <= 1'b0;
                end
                ST_INSTART : begin
                    // Prepare to send data; read first byte from memory.
                    s_bufptr <= s_bufptr + 1'b1;
                    s_endpt_tx_en <= 1'b1;
                end
                ST_INSEND :
                    // Sending data
                     if ( usbt_txrdy == 1) begin
                        // Need to provide the next data byte;
                        // stop when we reach the end of the TX buffer;
                        // stop when we reach the packet size limit.
                    s_bufptr <= s_bufptr + 1;
                    end
                ST_OUTRECV :
                    // Receiving data
                    if ( usbt_rxrdy == 1) begin
                        // Got data byte
                        `ifdef HSSUPPORT
                            s_nyet <= ~s_endpt_rxrdy;
                        `endif
                    end
                default:;
            endcase
        end
    end
    /*
    always @(posedge clk_i) begin
        // State machine
        if (s_reset == 1) begin
            s_state  <= ST_IDLE;
            s_bufptr <= 0;//to_unsigned(0, BUFPTR_SIZE);
        end
        else if (usbi_usbrst == 1) begin
            s_state  <= ST_IDLE;
            s_bufptr <= 0;//to_unsigned(0, BUFPTR_SIZE);
        end
        else begin
            case (s_state)
                ST_IDLE : begin
                    // Idle; wait for a transaction
                    s_nyet <= 0;
                    s_endpt_tx_en <= 1'b0;
                    if ((usbt_out == 1)&&(|endpt_out))begin
                        // Start of OUT transaction
                        if (s_halt_out == 1) begin
                            // Endpoint halted
                            s_state <= ST_STALL;
                        end
                        else if (s_endpt_rxrdy == 1) begin
                            // Prepare to receive data
                            s_state <= ST_OUTRECV;
                        end
                        else begin
                            // We have no room to store a new packet
                            s_state <= ST_OUTNAK;
                        end
                    end
                    else if (usbt_setup == 1)begin
                        s_state <= ST_SETUP;
                    end
                    else if ((usbt_in == 1)&&(|endpt_in)) begin
                        // Start of IN transaction
                        if (s_halt_in == 1)
                            // Endpoint halted
                            s_state <= ST_STALL;
                        else if (s_endpt_txcork == 0) begin
                            // Prepare to send data
                            s_bufptr <= 0;
                            s_state <= ST_INSTART;
                            s_endpt_tx_en <= 1'b1;
                        end else begin
                            // We have no data to send
                            s_state <= ST_NAK;
                        end
                    end
                    `ifdef HSSUPPORT
                        else if ((usbt_ping == 1) && (|endpt_out)) begin
                             // Start of PING transaction
                            if (s_endpt_rxrdy == 1) begin
                                // There is room in the RX buffer for another packet; do nothing (ACK).
                                s_state <= ST_IDLE;
                            end
                            else begin
                                // There is no room in the RX buffer; respond with NAK.
                                s_state <= ST_NAK;
                            end
                        end
                    `endif
                end
                ST_STALL :
                    // Wait for end of transaction
                    if ((usbt_in == 0) && (usbt_out == 0) && (usbt_ping == 0))
                        s_state <= ST_IDLE;
                ST_NAK :
                    // Wait for end of transaction
                    if ((usbt_in == 0) && (usbt_out == 0) && (usbt_ping == 0))
                        s_state <= ST_IDLE;
                ST_INSTART : begin
                    // Prepare to send data; read first byte from memory.
                    if (usbt_in == 0)
                        // Transaction canceled.
                        s_state <= ST_IDLE;
                    else if (s_bufptr == s_txbuf_stop) begin
                        // The TX buffer is empty, || a previous empty packet
                        // is unacknowledged, || the TX buffer is corked;
                        // must send an empty packet.
                        s_state <= ST_INDONE;
                    end
                    else begin
                        // Send a non-empty packet.
                        s_bufptr <= s_bufptr + 1;
                        s_state <= ST_INSEND;
                    end
                end
                ST_INSEND :
                    // Sending data
                    if (usbt_in == 0)
                        // Transaction canceled.
                        s_state <= ST_IDLE;
                     else if ( usbt_txrdy == 1) begin
                        // Need to provide the next data byte;
                        // stop when we reach the end of the TX buffer;
                        // stop when we reach the packet size limit.
                        if (s_bufptr == s_txbuf_stop) begin
                            // No more bytes
                            s_state <= ST_INDONE;
                        end
                        else begin
                            s_bufptr <= s_bufptr + 1;
                        end
                    end
                ST_INDONE : begin
                    // Done sending packet; wait for ACK.
                    if (usbt_in == 0) begin
                        // No acknowledgement
                        // Set limit for next packet to the same point
                        // Done
                        s_state <= ST_IDLE;
                    end
                    else if ( usbt_fin == 1) begin
                        // Got acknowledgement
                        s_state <= ST_IDLE;
                    end
                end
                ST_SETUP :
                    if (usbt_setup == 0) begin
                        s_state <= ST_IDLE;
                    end
                ST_OUTRECV :
                    // Receiving data
                    if (usbt_out == 0) begin
                        // Transaction ended.
                        // If the transaction was succesful, usbt_fin has been
                        // asserted in the previous cycle && has triggered
                        // an update of s_rxbuf_head.
                        s_state <= ST_IDLE;
                    end
                    else if ( usbt_rxrdy == 1) begin
                        // Got data byte
                        `ifdef HSSUPPORT
                            s_nyet <= ~s_endpt_rxrdy;
                        `endif
                    end
                ST_OUTNAK :
                    // Receiving data while we don't have room to store it
                    if (usbt_out == 0)
                        // End of transaction
                        s_state <= ST_IDLE;
                    else if (usbt_rxrdy == 1)
                        // This is a new (non-duplicate) packet, but we can
                        // not store it; so respond with NAK.
                        if (usbt_type == 1'b1) begin
                            s_state <= ST_IDLE;
                        end
                        else if (usbt_osync == s_osync) begin
                            s_state <= ST_NAK;
                        end
                default:
                    s_state <= ST_IDLE;
            endcase
        end
    end
    */

    // It is always a fight to get the synthesizer to infer block RAM.
    // The problem is we need dual port RAM with read-enable wires.
    // The recommended coding style, with registered read addresses,
    // does not work in this case.
    // The code below generates three RAM blocks on the Xilinx Spartan-3,
    // but it is doubtful whether it will work on other FPGA families.




//==============================================================
//====== RX
reg [7:0] rxdat_d0;
reg [7:0] rxdat_d1;
reg [7:0] rxdat_d2;
reg       rxval_d0;
reg       rxval_d1;
reg       rxval_d2;
always @ (posedge clk_i, posedge reset_i) begin
    if (reset_i) begin
        rxdat_d0 <= 8'd0;
        rxdat_d1 <= 8'd0;
        rxdat_d2 <= 8'd0;
        rxval_d0 <= 1'd0;
        rxval_d1 <= 1'd0;
        rxval_d2 <= 1'd0;
    end
    else begin
        if (cur_state == ST_OUTRECV && usbt_rxrdy == 1) begin
            rxdat_d0 <= usbt_rxdat;
            rxdat_d1 <= rxdat_d0;
            rxdat_d2 <= rxdat_d1;
            rxval_d0 <= 1'b1;
            rxval_d1 <= rxval_d0;
            rxval_d2 <= rxval_d1;
        end
        else if (cur_state == ST_SETUP && usbt_rxrdy == 1) begin
            rxdat_d0 <= usbt_rxdat;
            rxdat_d1 <= rxdat_d0;
            rxdat_d2 <= rxdat_d1;
            rxval_d0 <= 1'b1;
            rxval_d1 <= rxval_d0;
            rxval_d2 <= rxval_d1;
        end
        else if (cur_state == ST_OUTRECV && usbt_out == 0) begin
            rxdat_d0 <= 8'd0;
            rxdat_d1 <= 8'd0;
            rxdat_d2 <= 8'd0;
            rxval_d0 <= 1'd0;
            rxval_d1 <= 1'd0;
            rxval_d2 <= 1'd0;
        end
        else if (cur_state == ST_SETUP && usbt_setup == 0) begin
            rxdat_d0 <= 8'd0;
            rxdat_d1 <= 8'd0;
            rxdat_d2 <= 8'd0;
            rxval_d0 <= 1'd0;
            rxval_d1 <= 1'd0;
            rxval_d2 <= 1'd0;
        end
        else begin
            rxdat_d2 <= 8'd0;
            rxval_d2 <= 1'd0;
        end
    end
end

reg rx_packet_valid;
always @ (posedge clk_i, posedge reset_i) begin
    if (reset_i) begin
        rx_packet_valid <= 1'b0;
    end
    else begin
        if (cur_state == ST_OUTRECV) begin
            if (usbt_fin == 1) begin
                if (usbt_type == 1'b1) begin
                    rx_packet_valid <= 1'b1;
                end
                else if (usbt_osync == s_osync) begin
                    rx_packet_valid <= 1'b1;
                end
                else begin
                    rx_packet_valid <= 1'b0;
                end
            end
            else begin
                rx_packet_valid <= 1'b0;
            end
        end
        else begin
            rx_packet_valid <= 1'b0;
        end
    end
end
assign txpktfin_o = (cur_state == ST_INDONE)&(usbt_fin == 1);

assign txbuf_rdat = txdat_i;

assign rxdat_o  = ((cur_state == ST_OUTRECV)|(cur_state == ST_SETUP)) ? rxdat_d2 : 0;
assign rxval_o  = ((cur_state == ST_OUTRECV)|(cur_state == ST_SETUP)) ? rxval_d2 : 0;
assign rxact_o  = (cur_state == ST_OUTRECV);
assign rxpktval_o = rx_packet_valid;
assign setup_o = (cur_state == ST_SETUP);
assign endpt_o  = usbt_endpt;
assign txpop_o  = usbt_txrdy;
assign txact_o  = s_endpt_tx_en;


//==============================================================
//======Descriptor ROM Read
    // Lookup address/length of the selected descriptor (combinatorial).
    //always @(usbc_dsctyp, usbc_dscinx, highspeed_o)
    assign desc_index_o = usbc_dscinx;
    assign desc_type_o  = usbc_dsctyp;
    always @(*)
    begin
        descrom_start <= 0;//to_unsigned(0, descrom_start_LEN);
        usbc_dsclen <= 0;//to_unsigned(0, usbc_dsclen_LEN);
        case (usbc_dsctyp)
            8'h01 : begin   // device descriptor
                descrom_start <= desc_dev_addr_i;
                usbc_dsclen   <= desc_dev_len_i;
            end
            8'h02 : begin   // configuration descriptor
                if (usbc_dscinx == 0) begin
                    `ifdef HSSUPPORT
                       if (highspeed_o == 1) begin
                           descrom_start <= desc_hscfg_addr_i;
                           usbc_dsclen   <= desc_hscfg_len_i;
                       end else begin
                           descrom_start <= desc_fscfg_addr_i;
                           usbc_dsclen   <= desc_fscfg_len_i;
                       end
                    `else
                       descrom_start <= desc_fscfg_addr_i;
                       usbc_dsclen   <= desc_fscfg_len_i;
                    `endif
                end
            end
            8'h03 :    // string descriptor
                if (desc_have_strings_i)
                    case (usbc_dscinx)
                        0: begin // supported languages
                            descrom_start <= desc_strlang_addr_i;
                            usbc_dsclen <= 4;
                        end
                        1: begin // vendor name
                            descrom_start <= desc_strvendor_addr_i;
                            usbc_dsclen <= desc_strvendor_len_i;
                        end
                        2 : begin // product name
                            descrom_start <= desc_strproduct_addr_i;
                            usbc_dsclen <= desc_strproduct_len_i;
                        end
                        3: begin // serial number
                            descrom_start <= desc_strserial_addr_i;
                            usbc_dsclen <= desc_strserial_len_i;
                        end
                        default : begin
                            descrom_start <= desc_strserial_addr_i;
                            usbc_dsclen <= desc_strserial_len_i;
                        end
                            // unsupported descriptor index
                    endcase
            8'h06 :   // device qualifier
                `ifdef HSSUPPORT
                    begin
                        descrom_start <= desc_qual_addr_i;
                        usbc_dsclen   <= desc_qual_len_i;
                    end
                `else
                    ;
                `endif
            8'h07 :   // other speed configuration
                `ifdef HSSUPPORT
                    if (usbc_dscinx == 0) begin
                        if (highspeed_o == 1) begin
                            descrom_start <= desc_fscfg_addr_i;
                            usbc_dsclen   <= desc_fscfg_len_i;
                        end else begin
                            descrom_start <= desc_hscfg_addr_i;
                            usbc_dsclen   <= desc_hscfg_len_i;
                        end
                    end
                `else
                    ;
                `endif
            8'h22 :   // request HID report
                begin
                    descrom_start <= desc_hidrpt_addr_i;
                    usbc_dsclen   <= desc_hidrpt_len_i;
                end
            default :
                ;
                // unsupported descriptor type
        endcase
    end

    always @ (posedge clk_i)
    begin
        if (usbc_dscrd == 1)
            `ifdef HSSUPPORT
                if (usbc_dscoff == 1 && usbc_dsctyp == 3'b111)
                    // Disguise the configuration descriptor as an
                    // other_speed_configuration descriptor.
                    descrom_raddr <= desc_oscfg_addr_i;
                else
                    descrom_raddr <= descrom_start + usbc_dscoff;
            `else
                descrom_raddr <= descrom_start + usbc_dscoff;
            `endif
            //if (`HSSUPPORT && usbc_dscoff == 1 && usbc_dsctyp == 3'b111)
            //    // Disguise the configuration descriptor as an
            //    // other_speed_configuration descriptor.
            //    descrom_raddr <= desc_oscfg_addr_i;
            //else
            //    descrom_raddr <= descrom_start + usbc_dscoff;
    end
    assign descrom_raddr_o = descrom_raddr;
endmodule

`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////////
//
//  USB 2.0 Initialization, handshake and reset detection.
//
//  This entity provides the following functions:
//
//    * USB bus attachment: At powerup and after a RESET signal, switch to
//      non-driving mode, wait for 17 ms, then attach to the USB bus. This
//      should ensure that the host notices our reattachment and initiates
//      a reset procedure.
//
//    * High speed handshake (if HSSUPPORT enabled): attempt to enter
//      high speed mode after a bus reset.
//
//    * Monitor the linestate for reset and/or suspend signalling.
//
//  The low-level interface connects to an UTMI compliant USB PHY such as
//  the SMSC GT3200. The UTMI interface must be configured for 60 MHz operation
//  with an 8-bit data bus.
//
//////////////////////////////////////////////////////////////////////////////////////

`define TRUE  1'b1
`define FALSE 1'b0
//`define TIME_WTFS 1
//`define TIME_RESET 1
//`define TIME_SUSPRST 1
//`define TIME_FILT 1

//module usb_init #(
module `getname(usb_init,`module_name)
//#(  //Support high speed mode.
//    //parameter HSSUPPORT = 0
//)
(
    // 60 MHz UTMI clock.
    input wire CLK,

    // Synchronous reset; triggers detach and reattach to the USB bus.
    input wire RESET,

    input wire I_USB_TEST_EN,
    // High for one clock if a reset signal is detected on the USB bus.
    output wire I_USBRST,

    // High when attached to the host in high speed mode.
    output wire I_HIGHSPEED,

    // High when suspended.
    // Reset of this signal is asynchronous.
    // This signal may be used to drive (inverted) the UTMI SuspendM pin.
    output wire I_SUSPEND,

    // High to tell usb_packet that it must drive a continuous K state.
    output wire P_CHIRPK,

    // Connect to the UTMI Reset signal.
    output wire PHY_RESET,

    // Connect to the UTMI LineState signal.
    input wire [1 : 0] PHY_LINESTATE,

    // Cconnect to the UTMI OpMode signal.
    output wire [1 : 0] PHY_OPMODE,

    // Connect to the UTMI XcvrSelect signal (0 = high speed, 1 = full speed).
    output wire [1 : 0] PHY_XCVRSELECT,

    // Connect to the UTMI TermSelect signal (0 = high speed, 1 = full speed).
    output wire PHY_TERMSELECT
);



    // Time from bus idle until device suspend (3 ms).
    localparam TIME_SUSPEND = 20'd180000;

    // Time from start of SE0 until detection of reset signal (2.5 us + 1000%)
    // add 5us for falling edge.
    localparam TIME_RESET = 16'd10000;

    // Time to wait for good SE0 when waking up from suspend (6 ms).
    localparam TIME_SUSPRST = 20'd360000;

    // Duration of chirp K from device during high speed detection (1 ms + 20%).
    localparam TIME_CHIRPK  = 20'd72000;

    // Minimum duration of chirp J/K during high speed detection (2.5 us + 10%).
    localparam TIME_FILT = 8'd165;

    // Time to wait for chirp until giving up (1.1 ms).
    localparam TIME_WTFS = 20'd66000;

    // Time to wait after reverting to full-speed before sampling the bus (100 us).
    localparam TIME_WTRSTHS = 20'd6000;

    //17ms
    localparam TIME_OVERFLOW = 20'd1020000;

    // State machine
    localparam ST_INIT        = 4'h0;
    localparam ST_FSRESET    = 4'h1;
    localparam ST_FULLSPEED    = 4'h2;
    localparam ST_SUSPEND    = 4'h3;
    localparam ST_SUSPRESET    = 4'h4;
    localparam ST_SENDCHIRP    = 4'h5;
    localparam ST_RECVCHIRP    = 4'h6;
    localparam ST_HIGHSPEED    = 4'h7;
    localparam ST_HSREVERT    = 4'h8;

    reg [3 : 0] s_state = ST_INIT;

    // Timers.
    reg [15 : 0] s_timer1;
    reg [19 : 0] s_timer2 = 'h0;

    // Count J/K chirps.
    reg [2 : 0] s_chirpcnt;

    // High if the device is operating in high speed (or suspended from high speed).
    reg s_highspeed = 'b0;

    // High if the device is currently suspended.
    // Reset of this signal is asynchronous.
    reg s_suspend = 'b0;

    // Input registers.
    reg [1 : 0] s_linestate;
`ifdef HSSUPPORT
    reg [1 : 0] s_usb_test_en;
`endif

    // Output registers.
    reg         s_reset         = 'b1;
    reg [1 : 0] s_opmode        = 'b01;
    reg         s_xcvrselect    = 'b1;
    reg         s_termselect    = 'b1;
    reg         s_chirpk        = 'b0;

    reg v_clrtimer1;
    reg v_clrtimer2;

///////////
    assign I_USBRST          = s_reset;
    assign I_HIGHSPEED       = s_highspeed;
    assign I_SUSPEND         = s_suspend;
    assign P_CHIRPK          = s_chirpk;
    assign PHY_RESET         = s_reset;
    assign PHY_OPMODE        = s_opmode;
    `ifdef LSSUPPORT
        assign PHY_XCVRSELECT = 2'b10;
    `else
        assign PHY_XCVRSELECT = {1'b0,s_xcvrselect};
    `endif
    assign PHY_TERMSELECT    = s_termselect;



    // Synchronous process.
    always@(posedge CLK) begin
        // By default, do not clear the timers.
        v_clrtimer1 <= 1'b0;
        v_clrtimer2 <= 1'b0;
        // Register linestate input.
        s_linestate <= PHY_LINESTATE;
`ifdef HSSUPPORT
        s_usb_test_en <= I_USB_TEST_EN;
`endif
        // Default assignments to registers.
        s_reset  <= 1'b0;
        s_chirpk <= 1'b0;
        if (RESET) begin
            // Reset PHY.
            s_reset      <= 1'b1;
            s_opmode     <= 2'b01;
            s_xcvrselect <= 1'b1;
            s_termselect <= 1'b1;
            // Go to ST_INIT state and wait until bus attachment.
            v_clrtimer1  <= 1'b1;
            v_clrtimer2  <= 1'b1;
            s_highspeed  <= 1'b0;
            s_state      <= ST_INIT;
        end
        else begin
            //////////
            case(s_state)
                ST_INIT : begin
                    // Wait before attaching to bus.
                    s_opmode     <= 2'b01;   // non-driving
                    s_xcvrselect <= 1'b1;    // full speed
                    s_termselect <= 1'b1;    // full speed
                    v_clrtimer1  <= 1'b1;
                    if(s_timer2 >= TIME_OVERFLOW) begin
                        // Timer2 overflows after ~ 17 ms; attach to bus.
                        v_clrtimer2 <= 1'b1;
                        s_state     <= ST_FULLSPEED;
                    end
                end
//////////
                ST_FSRESET : begin
                    // Waiting for end of reset before full speed operation.
                    s_highspeed  <= 1'b0;
                    s_opmode     <= 2'b00;   // normal
                    s_xcvrselect <= 1'b1;    // full speed
                    s_termselect <= 1'b1;    // full speed
                    v_clrtimer1  <= 1'b1;
                    v_clrtimer2  <= 1'b1;
                    if(s_linestate != 2'b00) begin
                        // Reset signal ended.
                        s_state  <= ST_FULLSPEED;
                    end
                end
                ST_FULLSPEED : begin
                    // Operating in full speed.
                    s_highspeed  <= 1'b0;
                    s_opmode     <= 2'b00;   // normal
                    s_xcvrselect <= 1'b1;    // full speed
                    s_termselect <= 1'b1;    // full speed
                    if(s_linestate != 2'b00) begin
                        // Bus not in SE0 state; clear reset timer.
                        v_clrtimer1 <= 1'b1;
                    end
                    if(s_linestate != 2'b01) begin
                        // Bus not in J state; clear suspend timer.
                        v_clrtimer2 <= 1'b1;
                    end
                    if(s_timer1 == TIME_RESET) begin
                        // Bus has been in SE0 state for TIME_RESET;
                        // this is a reset signal.
                        s_reset <= 1'b1;
                        `ifdef HSSUPPORT
                            s_state <= ST_SENDCHIRP;
                        `else
                            s_state <= ST_FSRESET;
                        `endif
                        //if(HSSUPPORT == `TRUE) begin
                        //    s_state <= ST_SENDCHIRP;
                        //end
                        //else begin
                        //    s_state <= ST_FSRESET;
                        //end
                    end
                    else if(s_timer2 == TIME_SUSPEND) begin
                        // Bus has been idle for TIME_SUSPEND;
                        // go to suspend state.
                        s_state <= ST_SUSPEND;
                    end
                end
                ST_SUSPEND : begin
                    // Suspended; waiting for resume signal.
                    // Possibly our clock will be disabled; wake up
                    // is initiated by the asynchronous reset of s_suspend.
                    s_opmode     <= 2'b00;   // normal
                    s_xcvrselect <= 'b1;    // full speed
                    s_termselect <= 'b1;    // full speed
                    v_clrtimer1  <= 'b1;
                    v_clrtimer2  <= 'b1;
                    if(s_linestate != 'b01) begin
                        // Bus not in J state; resume.
                        `ifdef HSSUPPORT
                            if(s_highspeed == 1'b1) begin
                                // High speed resume protocol.
                                if(s_linestate == 2'b10) begin
                                    // Bus in K state; resume to high speed.
                                    s_state <= ST_HIGHSPEED;
                                end
                                else if(s_linestate == 2'b00) begin
                                    // Bus in SE0 state; start reset detection.
                                    s_state <= ST_SUSPRESET;
                                end
                            end
                            else begin
                                // Resume to full speed.
                                s_state <= ST_FULLSPEED;
                            end
                        `else
                            // Resume to full speed.
                            s_state <= ST_FULLSPEED;
                        `endif
                        //if(HSSUPPORT == `TRUE && s_highspeed == 1'b1) begin
                        //    // High speed resume protocol.
                        //    if(s_linestate == 2'b10) begin
                        //        // Bus in K state; resume to high speed.
                        //        s_state <= ST_HIGHSPEED;
                        //    end
                        //    else if(s_linestate == 2'b00) begin
                        //        // Bus in SE0 state; start reset detection.
                        //        s_state <= ST_SUSPRESET;
                        //    end
                        //end
                        //else begin
                        //    // Resume to full speed.
                        //    s_state <= ST_FULLSPEED;
                        //end
                    end
                end
                ST_SUSPRESET : begin
                    // Wake up in SE0 state; wait for proper reset signal.
                    s_opmode     <= 2'b00;   // normal
                    s_xcvrselect <= 1'b1;    // full speed
                    s_termselect <= 1'b1;    // full speed
                    if(s_linestate != 2'b00) begin
                        // Bus not in SE0 state; clear reset timer.
                        v_clrtimer1 <= 1'b1;
                    end
                    if(s_timer1 == TIME_RESET) begin
                        // Bus has been in SE0 state for TIME_RESET;
                        // this is a reset signal.
                        s_reset     <= 1'b1;
                        v_clrtimer2 <= 1'b1;
                        s_state     <= ST_SENDCHIRP;
                    end
                    if(s_timer2 == TIME_SUSPRST) begin
                        // Still no proper reset signal; go back to sleep.
                        s_state <= ST_SUSPEND;
                    end
                end
                ST_SENDCHIRP : begin
                    // Sending chirp K for a duration of TIME_CHIRPK.
                    s_highspeed  <= 1'b0;
                    s_opmode     <= 2'b10;   // disable bit stuffing
                    s_xcvrselect <= 1'b0;    // high speed
                    s_termselect <= 1'b1;    // full speed
                    s_chirpk     <= 1'b1;    // send chirp K
                    v_clrtimer1  <= 1'b1;
                    if(s_timer2 == TIME_CHIRPK) begin
                        // end of chirp K
                        v_clrtimer2 <= 1'b1;
                        s_chirpcnt  <= 3'b000;
                        s_state     <= ST_RECVCHIRP;
                    end
                end
                ST_RECVCHIRP : begin
                    // Waiting for K-J-K-J-K-J chirps.
                    // Note: DO NOT switch Opmode to normal yet; there
                    // may be pending bits in the transmission buffer.
                    s_opmode     <= 2'b10;   // disable bit stuffing
                    s_xcvrselect <= 1'b0;    // high speed
                    s_termselect <= 1'b1;    // full speed
                    if((s_chirpcnt[0] == 1'b0 && s_linestate != 2'b10) || (s_chirpcnt[0] == 1'b1 && s_linestate != 2'b01)) begin
                        // Not the linestate we want.
                        v_clrtimer1 <= 1'b1;
                    end
                    if(s_timer2 == TIME_WTFS) begin
                        // High speed detection failed; go to full speed.
                        v_clrtimer1 <= 1'b1;
                        v_clrtimer2 <= 1'b1;
                        s_state     <= ST_FSRESET;
                    end
                    else if (s_timer1 == TIME_FILT) begin
                        // We got the chirp we wanted.
                        if(s_chirpcnt == 5) begin
                            // This was the last chirp;
                            // we got a successful high speed handshake.
                            v_clrtimer2 <= 1'b1;
                            s_state     <= ST_HIGHSPEED;
                        end
                        s_chirpcnt  <= s_chirpcnt + 1;
                        v_clrtimer1 <= 1'b1;
                    end
                end
                ST_HIGHSPEED : begin
                    // Operating in high speed.
                    s_highspeed  <= 1'b1;
                    s_opmode     <= 2'b00;   // normal
                    s_xcvrselect <= 1'b0;    // high speed
                    s_termselect <= 1'b0;    // high speed
                    if(s_linestate != 2'b00) begin
                        // Bus not idle; clear revert timer.
                        v_clrtimer2 <= 1'b1;
                    end
                   `ifdef HSSUPPORT
                    else if (s_usb_test_en) begin
                        v_clrtimer2 <= 1'b1;
                    end
                   `endif
                    if(s_timer2 == TIME_SUSPEND) begin
                        // Bus has been idle for TIME_SUSPEND;
                        // revert to full speed.
                        v_clrtimer2 <= 1'b1;
                        s_state     <= ST_HSREVERT;
                    end
                end
                ST_HSREVERT : begin
                    // Revert to full speed and wait for 100 us.
                    s_opmode     <= 2'b00;   // normal
                    s_xcvrselect <= 1'b1;    // full speed
                    s_termselect <= 1'b1;    // full speed
                    if(s_timer2 == TIME_WTRSTHS) begin
                        v_clrtimer2 <= 1'b1;
                        if(s_linestate == 2'b00) begin
                            // Reset from high speed.
                            s_reset <= 1'b1;
                            s_state <= ST_SENDCHIRP;
                        end
                        else begin
                            // Suspend from high speed.
                            s_state <= ST_SUSPEND;
                        end
                    end
                end
//////////
            endcase
            //////////
            // Increment or clear timer1.
            if(v_clrtimer1 == 1'b1) begin
                s_timer1 <= 'h0;
            end
            else begin
                s_timer1 <= s_timer1 + 1;
            end

            // Increment or clear timer2.
            if(v_clrtimer2 == 1'b1) begin
                s_timer2 <= 'h0;
            end
            else begin
                s_timer2 <= s_timer2 + 1;
            end
        end
    end


///////////

    wire phy_linestate_rst;
    assign phy_linestate_rst =  (PHY_LINESTATE != 2'b01) ? 1'b1 : 1'b0;

    // Drive the s_suspend flipflop (synchronous set, asynchronous reset).
    always@(posedge CLK or posedge phy_linestate_rst) begin
        if(phy_linestate_rst) begin
            // The bus is not in full speed idle state;
            // reset the s_suspend flipflop.
            s_suspend <= 1'b0;
      end
        else begin
            if (s_state == ST_SUSPEND) begin
                // Bus is idle and FSM is in suspend state;
                // enable the s_suspend flipflop.
                s_suspend   <= 1'b1;
            end
        end
    end



endmodule


    //
//  USB 2.0 Transaction-level logic
//
//  This entity deals with transactions. A transaction consists of up to
//  three packets: token, data, handshake. This component supports four
//  transaction types:
//    * IN    (device-to-host bulk/interrupt/control transfer)
//    * OUT   (host-to-device bulk/interrupt/control transfer)
//    * SETUP (host-to-device control operation)
//    * PING  (flow control for host-to-device bulk/control transfer, HS only)
//  Isochronous transactions are not supported.
//
//  The low-level interface signals are named P_xxx and connect to
//  the usb_packet component.
//
//  The application interface signals are named T_xxx and operate as
//  follows:
//
//    * At the start of a transaction, either T_IN, T_OUT, T_SETUP or T_PING
//      rises to 1, indicating the transaction type.  At the same time,
//      T_ENDPT is set to the endpoint number for this transaction.
//      These signals are held for the duration of the transaction.
//
//  OUT and SETUP transactions:
//    * Each incoming byte is put on RXDAT and announced by asserting RXRDY.
//      These signals are valid for only one clock cycle.
//    * OSYNC is set to the transmitter's sync bit and held until the end
//      of the transaction.
//    * The last two bytes are CRC bytes; these should be ignored.
//    * Successfull completion is indicated by asserting T_FIN for one cycle.
//    * Receive errors are indicated by deasserting T_OUT/T_SETUP without
//      ever asserting T_FIN. In this case, the application must discard any
//      data already accepted during this transaction.
//    * It is probably safe to assume that the first assertion of T_RXRDY
//      does not immediately coincide with the rising T_OUT/T_SETUP signal.
//      The implementation of usb_control and usb_serial depend on this
//      assumption. The assumption may be false if PHY_RXACTIVE is low for
//      only one clock between token and data, and re-assertion of PHY_RXACTIVE
//      coincides with assertion of PHY_RXVALID. This is not explicitly
//      prohibited in the UTMI spec, but it just seems extremely unlikely.
//
//  OUT transactions:
//    * If the application is not ready to accept data, it should assert
//      either NAK or STALL. These signals must be set up as soon as the last
//      byte of the packet has been received, and kept stable until the end
//      of the transaction.
//    * If the application is ready to accept this OUT packet, but not ready
//      to accept a subsequent OUT packet, it may assert T_NYET. This signal
//      must be set up as soon as the last byte of the packet has been received
//      and kept stable until the end of the transaction. NYET is only valid
//      in high speed mode; in full speed mode, this entity will ignore the
//      NYET signal and send ACK instead.
//    * Note: NAK/STALL/NYET must not be used during SETUP transactions;
//      the standard specifies that SETUP transactions must always be ACK-ed
//      and errors reported during the subsequent data transaction.
//
//  IN transactions:
//    * The application should assert SEND, put the sync bit on ISYNC
//      and put the first byte on TXDAT. The component will assert TXRDY
//      to acknowledge each byte; in the following cycle, the application
//      must either provide the next data byte or release SEND to indicate
//      the end of the packet.
//      After T_IN rises, the application must respond within 2 clock cycles.
//    * The application must not include CRC bytes.
//    * If the application is not ready to send data, it should assert
//      either NAK or STALL and keep it asserted until the end of the
//      transaction.
//    * An empty packet can be sent by keeping SEND, NAK and STALL
//      deasserted; the component will interpret this as a zero-length SEND.
//    * Successfull completion of an IN transaction is indicated by
//      asserting FIN for one cycle.
//    * Timeout is indicated by deasserting T_IN without ever asserting FIN.
//      In this case, the application must assume that the IN transaction
//      failed.
//
//  PING transactions:
//    * In high speed mode only, the host may send a PING transaction to which
//      the application must respond with either ACK or NAK to indicate whether
//      it is willing to receive a full sized OUT transaction.
//    * When a PING is received, T_PING is raised and at the same time T_ENDPT
//      becomes valid. The application must respond within 2 clock cycles.
//    * If the application is not ready to received data, it should assert T_NAK
//      and keep it asserted until the end of the transaction. If the application
//      does not assert either T_NAK or T_STALL, an ACK response will be sent.
//

//module usb_transact #(
module `getname(usb_transact,`module_name)
//#(
//    parameter HSSUPPORT = 0
//)
(
        // 60 MHz UTMI clock.
        input CLK,

        // Synchronous reset of this entity.
        input RESET,

        input C_TESTNAK,
        // High during IN transactions.
        output T_IN,

        // High during OUT transactions.
        output T_OUT,

        // High during SOF transactions.
        output T_SOF,

        // High during SETUP transactions.
        output T_SETUP, /* synthesis syn_keep = 1 */

        // High during PING transactions.
        output T_PING,

        // Indicates successfull completion of a transaction.
        output T_FIN,

        // Device address.
        input [6:0] T_ADDR,

        // Endpoint number for current transaction.
        output [3:0] T_ENDPT,

        // Triggers a NAK response to IN/OUT/PING.
        input T_NAK,

        // Triggers a STALL response to IN/OUT.
        input T_STALL,

        // Triggers a NYET response to OUT.
        input T_NYET,

        // High while application has data to send (in response to OUT).
        input T_SEND,

        // Sync bit to use for IN transactions.
        input T_ISYNC,

        // Sync bit used for the current OUT transaction.
        output T_OSYNC,

        // Indicates next byte received.
        output T_RXRDY,

        // Indicates Endpoint Transactions Type.
        input [1:0] T_TYPE,
        input [3:0] T_PID_DATA,

        // Received data; valid when T_RXRDY = '1'.
        output [7:0] T_RXDAT,

        // Requests next byte to transmit; application must update T_TXDAT or T_SEND in next cycle.
        output T_TXRDY,

        // Data byte to transmit; must be valid when T_SEND = '1'.
        input [7:0] T_TXDAT,

        // Connect to I_HIGHSPEED from usb_init.
        input I_HIGHSPEED,

        // Connect to P_RXACT from usb_packet.
        input P_RXACT,

        // Connect to P_RXRDY from usb_packet.
        input P_RXRDY,

        // Connect to P_RXFIN from usb_packet.
        input P_RXFIN,

        // Connect to P_RXDAT from usb_packet.
        input [7:0] P_RXDAT,

        // Connect to P_TXACT towards usb_packet.
        output P_TXACT,

        // Connect to P_TXRDY from usb_packet.
        input P_TXRDY,

        // Connect to P_TXDAT towards usb_packet.
        output [7:0] P_TXDAT,

        output reg ack_timeout_o,
        output reg ack_received_o,
        output reg ack_bad_packet_o
        ,output wire [3:0] transact_state_o
        ,output wire stuck_in_2nd_or_3rd_state_o
    );


    // PID constants
    localparam pid_out   = 4'b0001;
    localparam pid_in    = 4'b1001;
    localparam pid_sof   = 4'b0101;
    localparam pid_setup = 4'b1101;
    localparam pid_ack   = 4'b0010;
    localparam pid_nak   = 4'b1010;
    localparam pid_stall = 4'b1110;
    localparam pid_nyet  = 4'b0110;
    localparam pid_ping  = 4'b0100;
    localparam pid_data  = 3'b011;

    // State machine
    localparam ST_IDLE      = 16'h0000;
    localparam ST_SKIP      = 16'h0001;
    localparam ST_GETTOKEN1 = 16'h0002;
    localparam ST_GETTOKEN2 = 16'h0004;
    localparam ST_GETTOKEN3 = 16'h0008;
    localparam ST_GOTTOKEN  = 16'h0010;
    localparam ST_SENDSHAKE = 16'h0020;
    localparam ST_GETDATA   = 16'h0040;
    localparam ST_GOTDATA   = 16'h0080;
    localparam ST_SENDDATA  = 16'h0100;
    localparam ST_SENDING   = 16'h0200;
    localparam ST_WAITACK   = 16'h0400;
    localparam ST_WAITSKIP  = 16'h0800;
    localparam ST_GETACK    = 16'h1000;
    

    //reg [3:0] s_state = ST_IDLE;
    reg [15:0] s_state;
    wire s_active;

    reg [3:0] transact_state;
    always @(posedge CLK) begin
        case (s_state)
            ST_IDLE     :   begin   transact_state <= 4'd0    ;end
            ST_SKIP     :   begin   transact_state <= 4'd1    ;end  
            ST_GETTOKEN1:   begin   transact_state <= 4'd2    ;end
            ST_GETTOKEN2:   begin   transact_state <= 4'd3    ;end
            ST_GETTOKEN3:   begin   transact_state <= 4'd4    ;end
            ST_GOTTOKEN :   begin   transact_state <= 4'd5    ;end
            ST_SENDSHAKE:   begin   transact_state <= 4'd6    ;end
            ST_GETDATA  :   begin   transact_state <= 4'd7    ;end
            ST_GOTDATA  :   begin   transact_state <= 4'd8    ;end
            ST_SENDDATA :   begin   transact_state <= 4'd9    ;end
            ST_SENDING  :   begin   transact_state <= 4'd10   ;end
            ST_WAITACK  :   begin   transact_state <= 4'd11   ;end
            ST_WAITSKIP :   begin   transact_state <= 4'd12   ;end
            ST_GETACK   :   begin   transact_state <= 4'd13   ;end
            default     :   begin   transact_state <= 4'd15   ;end
        endcase
    end
    assign transact_state_o = transact_state;

    wire stuck_in_2nd_or_3rd_state;
    reg [3:0] stuck_in_2nd_or_3rd_state_counter = 4'b0;
    assign stuck_in_2nd_or_3rd_state = (stuck_in_2nd_or_3rd_state_counter >= 4'd10) ? 1'b1 : 1'b0;

    assign stuck_in_2nd_or_3rd_state_o = stuck_in_2nd_or_3rd_state;
    // Transaction state
    reg s_in = 0;
    reg s_out = 0;
    reg s_sof = 0;
    reg s_in_valid;
    reg s_out_valid;
    reg s_sof_valid;
    reg s_setup  /* synthesis syn_keep = 1 */;
    reg s_ping = 0;
    reg s_finished = 0;

    // Previous value of P_RXACT; needed to detect bad packet while waiting for host.
    reg s_prevrxact;

    // PID byte to use for outgoing packet (ST_SENDSHAKE or ST_SENDDATA)
    reg [3:0] s_sendpid;
    wire [7:0] s_sendpid_mirrored;
    assign s_sendpid_mirrored = {~s_sendpid, s_sendpid};

    // Registered output signals
    reg [3:0] s_endpt = 4'h0;
    reg s_osync = 1'b0;

    // In full speed mode, we must time out an expected host response after
    // 16 to 18 bit periods. In high speed mode, we must time out after
    // 736 to 816 bit periods. We can not get accurate timing because we don't
    // know the delay due to CRC, EOP, SYNC and UTMI pipeline. (We should use
    // PHY_LINESTATE for timing, but we don't.) So we just use a much longer
    // timeout; wait_timeout_fs = 511 cycles = 102 bit periods;
    // wait_timeout_hs = 127 cycles = 1020 bit periods.
    //localparam wait_timeout_fs = 9'b111111111;
    localparam wait_timeout_ls = 16'b0001111111111111;
    localparam wait_timeout_fs = 16'b0000000111111111;
    localparam wait_timeout_hs = 16'b0000000011111111;

    // In full speed mode, we must wait at least 2 and at most 6.5 bit periods
    // before responding to the host. We have wait_send_fs = 14 cycles from
    // rising T_IN/OUT/SETUP until valid T_NAK; equals 16 cycles from rising
    // P_RXFIN until rising P_TXACT; equals 18 cycles from falling PHY_RXACTIVE
    // until rising PHY_TXVALID. Including pipeline delay in the UTMI, we end
    // up with 2 to 5 bit periods from SE0-to-J until SYNC.
    localparam wait_send_fs = 16'b0000000000001110;
    localparam wait_send_ls = 16'b0000000001110000;

    // In high speed mode, we must wait at least 8 and at most 192 bit periods
    // before responding to the host. We give the application wait_send_hs = 2
    // cycles to get its act together; i.e. from rising T_IN/OUT/SETUP/PING
    // until valid T_NAK/STALL/NYET/SEND. This corresponds to 4 cycles from
    // P_RXFIN until P_TXACT; equals 6 cycles from falling PHY_RXACTIVE until
    // rising PHY_TXVALID. Including pipeline delay in the UTMI, we end up
    // with 78 to 127 bit periods between packets.
    localparam wait_send_hs = 16'b0000000000000010;
    // localparam wait_send_hs = 16'b0000000000000000;

    // Count down timer.
    reg[15:0] wait_count;

    assign T_IN    = s_in_valid & s_active;  //s_in
    assign T_OUT   = s_out_valid & s_active; //s_out
    assign T_SOF   = s_sof_valid;//s_sof;
    assign T_SETUP = s_setup & s_active;
    assign T_PING  = s_ping & s_active;
    assign T_FIN   = s_finished;  // Note: T_FIN only occurs when s_state = ST_IDLE
    assign T_ENDPT = s_endpt;
    assign T_OSYNC = s_osync;

    // Received bytes
    assign T_RXRDY = (s_state == ST_GETDATA) ? P_RXRDY : 0;
    assign T_RXDAT = P_RXDAT;

    // Byte to transmit: handshake PID, data PID or data byte
    assign T_TXRDY = (s_state == ST_SENDING) ? P_TXRDY : 0;
    assign P_TXACT = (s_state == ST_SENDSHAKE || s_state == ST_SENDDATA || (s_state == ST_SENDING && T_SEND == 1)) ? 1 : 0;
    assign P_TXDAT = (s_state == ST_SENDSHAKE || s_state == ST_SENDDATA) ? s_sendpid_mirrored : T_TXDAT;

    // Assign control signals
    assign s_active =
                 (s_state == ST_IDLE || s_state == ST_GOTTOKEN ||
                  s_state == ST_SENDSHAKE ||
                  s_state == ST_GETDATA || s_state == ST_GOTDATA ||
                  s_state == ST_SENDDATA || s_state == ST_SENDING ||
                  s_state == ST_WAITACK || s_state == ST_WAITSKIP || s_state == ST_GETACK);
    
always @(posedge CLK)
    s_prevrxact     <= P_RXACT;

always @(posedge CLK /*or posedge RESET*/) begin
    if(RESET) begin
        // Reset this component
        s_state         <= ST_IDLE;
        s_in            <= 0;
        s_out           <= 0;
        s_sof           <= 0;
        s_in_valid      <= 1'b0;
        s_out_valid     <= 1'b0;
        s_sof_valid     <= 0;
        s_setup         <= 0;
        s_ping          <= 0;
        s_finished      <= 0;
        s_endpt         <= 0;
        s_osync         <= 0;
        wait_count      <= 0;
        s_sendpid       <= 0;
        ack_timeout_o   <= 1'b0;
        ack_received_o  <= 1'b0;
        ack_bad_packet_o<= 1'b0;
        stuck_in_2nd_or_3rd_state_counter <= 4'b0;
    end
    else begin
        case(s_state)
            ST_IDLE: begin
                // Idle; wait for incoming packet
                s_in            <= 0;
                s_out           <= 0;
                s_setup         <= 0;
                s_ping          <= 0;
                s_finished      <= 0;
                s_in_valid      <= 1'b0;
                s_out_valid     <= 1'b0;
                s_sof_valid     <= 0;
                ack_timeout_o   <= 1'b0;
                ack_received_o  <= 1'b0;
                ack_bad_packet_o<= 1'b0;
                stuck_in_2nd_or_3rd_state_counter <= 4'b0;
                if(P_RXRDY == 1) begin
                    case (P_RXDAT[3:0])
                        pid_out: begin
                            // OUT token
                            s_out   <= 1;
                            s_state <= ST_GETTOKEN1;
                        end
                        pid_in: begin
                            // IN token
                            s_in    <= 1;
                            s_state <= ST_GETTOKEN1;
                        end
                        pid_sof: begin
                            // IN token
                            s_sof   <= 1;
                            s_state <= ST_GETTOKEN1;
                        end
                        pid_setup: begin
                            // SETUP token
                            s_setup <= 1;
                            s_state <= ST_GETTOKEN1;
                        end
                        pid_ping: begin
                            // PING token
                            `ifdef HSSUPPORT
                                s_ping  <= 1;
                                s_state <= ST_GETTOKEN1;
                            `else
                                s_state <= ST_SKIP;
                            `endif
                            //if(HSSUPPORT) begin
                            //    s_ping  <= 1;
                            //    s_state <= ST_GETTOKEN1;
                            //end else begin
                            //    // no PINGing for full speed devices
                            //    s_state <= ST_SKIP;
                            //end
                        end
                        default: begin
                            // unexpected packet
                            s_state <= ST_SKIP;
                        end
                    endcase
                end
            end

            ST_SKIP: begin
                // Skip incoming packet and go back to IDLE
                stuck_in_2nd_or_3rd_state_counter <= 4'b0;
                if(P_RXACT == 0) begin
                    s_state <= ST_IDLE;
                end
            end
            ST_GETTOKEN1: begin
                
                // Receive and check 2nd byte of a token packet
                if(P_RXACT == 0) begin
                    // Bad packet
                    s_state <= ST_IDLE;
                    s_sof <= 1'b0;
                end else if(P_RXRDY == 1) begin
                    if(s_sof == 1) begin //SOF
                        s_state <= ST_GETTOKEN2;
                    end
                    else begin
                        // Store endpoint number
                        s_endpt[0] <= P_RXDAT[7];
                        // Check address
                        if ((C_TESTNAK)||(P_RXDAT[6:0] == T_ADDR)) begin
                            // Packet is addressed to us
                            s_state <= ST_GETTOKEN2;
                        end
                        else begin
                            // Packet not addressed to us
                            //s_state <= ST_GETTOKEN2;
                            s_state <= ST_SKIP;
                        end
                    end
                end

                if (stuck_in_2nd_or_3rd_state_counter < 4'd10) stuck_in_2nd_or_3rd_state_counter <= stuck_in_2nd_or_3rd_state_counter + 1'b1;
                else stuck_in_2nd_or_3rd_state_counter <= stuck_in_2nd_or_3rd_state_counter;

            end
            ST_GETTOKEN2: begin
                // Receive 3rd byte of token packet
                if (P_RXACT == 0) begin
                    // Bad packet
                    s_state <= ST_IDLE;
                    s_sof <= 1'b0;
                end
                else if (P_RXRDY == 1) begin
                    // Store endpoint number
                    if(s_sof == 1) begin //SOF
                        s_state <= ST_IDLE;
                        s_sof <= 1'b0;
                        s_sof_valid <= 1;
                    end
                    else begin
                        s_endpt[3:1] <= P_RXDAT[2:0];
                        s_state <= ST_GETTOKEN3;
                    end
                end

                if (stuck_in_2nd_or_3rd_state_counter < 4'd10) stuck_in_2nd_or_3rd_state_counter <= stuck_in_2nd_or_3rd_state_counter + 1'b1;
                else stuck_in_2nd_or_3rd_state_counter <= stuck_in_2nd_or_3rd_state_counter;

            end
            ST_GETTOKEN3: begin
                stuck_in_2nd_or_3rd_state_counter <= 4'b0;

                // Wait for end of incoming token packet
                if (P_RXFIN == 1) begin
                    // Token was ok
                    s_state <= ST_GOTTOKEN;
                    if (s_in) begin
                        s_in_valid <= 1'b1;
                        s_out_valid <= 1'b0;
                    end
                    else if (s_out) begin
                        s_in_valid <= 1'b0;
                        s_out_valid <= 1'b1;
                    end
                end else if(P_RXACT == 0) begin
                    // Token was bad
                    s_state <= ST_IDLE;
                end
                if (s_in == 1) begin
                       `ifdef HSSUPPORT
                           if (I_HIGHSPEED == 1)
                               wait_count <= wait_send_hs;
                           else
                               wait_count <= wait_send_fs;
                       `elsif FSSUPPORT
                           wait_count <= wait_send_fs;
                       `elsif LSSUPPORT
                           wait_count <= wait_send_ls;
                       `else
                           wait_count <= wait_send_fs;
                       `endif
                end
                `ifdef HSSUPPORT
                    else if (s_ping == 1) begin
                        if (I_HIGHSPEED == 1)
                            wait_count <= wait_send_hs;
                        else
                            wait_count <= wait_send_fs;
                    end
                `endif
                else begin
                    `ifdef HSSUPPORT
                        if (I_HIGHSPEED == 1)
                            wait_count <= wait_timeout_hs;
                        else
                            wait_count <= wait_timeout_fs;
                    `elsif FSSUPPORT
                        wait_count <= wait_timeout_fs;
                    `elsif LSSUPPORT
                        wait_count <= wait_timeout_ls;
                    `else
                        wait_count <= wait_timeout_fs;
                    `endif
                end
                //if ((s_in == 1) || (HSSUPPORT && (s_ping == 1))) begin
                //    if (HSSUPPORT && (I_HIGHSPEED == 1))
                //        wait_count <= wait_send_hs;
                //    else
                //        wait_count <= wait_send_fs;
                //end
                //else begin
                //    if (HSSUPPORT && (I_HIGHSPEED == 1))
                //        wait_count <= wait_timeout_hs;
                //    else
                //        wait_count <= wait_timeout_fs;
                //end
            end
            ST_GOTTOKEN: begin
                // Wait for data packet or wait for our turn to respond
                if (P_RXACT == 1) begin
                    if (P_RXRDY == 1) begin
                        // Got PID byte
                        if (((s_out == 1) || (s_setup == 1)) && (P_RXDAT[2:0] == pid_data)) begin
                            // This is the DATA packet we were waiting for
                            s_osync <= P_RXDAT[3];
                            s_state <= ST_GETDATA;
                        end    else begin
                            // Got unexpected packet
                            s_in_valid <= 0;
                            s_out_valid <= 0;
                            s_in    <= 0;
                            s_out   <= 0;
                            s_setup <= 0;
                            s_ping  <= 0;
                            case(P_RXDAT[3:0])
                                pid_out: begin
                                    // unexpected OUT token
                                    s_out <= 1;
                                    s_state <= ST_GETTOKEN1;
                                end
                                pid_in: begin
                                    // unexpected IN token
                                    s_in <= 1;
                                    s_state <= ST_GETTOKEN1;
                                end
                                pid_setup: begin
                                    // unexpected SETUP token
                                    s_setup <= 1;
                                    s_state <= ST_GETTOKEN1;
                                end
                                pid_ping: begin
                                    // unexpected PING token
                                    `ifdef HSSUPPORT
                                        s_ping  <= 1;
                                        s_state <= ST_GETTOKEN1;
                                    `else
                                        s_state <= ST_SKIP;
                                    `endif
                                    //if (HSSUPPORT) begin
                                    //    s_ping  <= 1;
                                    //    s_state <= ST_GETTOKEN1;
                                    //end
                                    //else begin
                                    //    // no PINGing for full speed devices
                                    //    s_state <= ST_SKIP;
                                    //end
                                end
                                default: begin
                                    // unexpected packet
                                    s_state <= ST_SKIP;
                                end
                            endcase
                        end
                    end
                end else if (s_prevrxact == 1) begin
                    // got bad packet
                    s_state <= ST_IDLE;
               end else if (s_in == 1) begin
                        // IN transaction: send response
                    if (T_STALL == 1) begin
                        s_state   <= ST_SENDSHAKE;
                        s_sendpid <= pid_stall;
                    end else if (T_NAK == 1) begin
                        s_state   <= ST_SENDSHAKE;
                        s_sendpid <= pid_nak;
                    end else begin
                        if (wait_count == 0)begin
                            s_state   <= ST_SENDDATA;
                            if (T_TYPE == 2'd1) begin //Isochronous Transactions
                                s_sendpid <= T_PID_DATA;
                            end
                            else begin
                                s_sendpid <= {T_ISYNC, pid_data};
                            end
                        end
                    end
                end
                `ifdef HSSUPPORT
                   //else if (HSSUPPORT && (s_ping == 1)) begin
                   else if ((s_ping == 1)) begin
                       // PING transaction: send handshake
                       s_state <= ST_SENDSHAKE;
                       if (T_STALL == 1)
                           s_sendpid <= pid_stall;
                       else if (T_NAK == 1)
                           s_sendpid <= pid_nak;
                       else
                           s_sendpid <= pid_ack;
                   end
                `endif
                else if (wait_count == 0)begin
                    // OUT/SETUP transaction:
                    // timeout while waiting for DATA packet
                    s_state <= ST_IDLE;
                end
                wait_count <= wait_count - 1;
            end
            ST_SENDSHAKE: begin
                // Send handshake packet
                if (P_TXRDY == 1) begin
                    // Handshake done, transaction completed
                    s_finished <= 1;
                    s_state <= ST_IDLE;
                end
            end
            ST_GETDATA: begin
                // Wait for end of incoming data packet
                if (P_RXFIN == 1) begin
                    // Data packet was good, respond with handshake
                    s_state <= ST_GOTDATA;
                end
                else if (P_RXACT == 0) begin
                    // Data packet was bad, ignore it
                    s_state <= ST_IDLE;
                end
                `ifdef HSSUPPORT
                    if (I_HIGHSPEED == 1)
                       wait_count <= wait_send_hs;
                    else
                       wait_count <= wait_send_fs;
                `elsif FSSUPPORT
                       wait_count <= wait_send_fs;
                `elsif LSSUPPORT
                       wait_count <= wait_send_ls;
                `else
                       wait_count <= wait_send_fs;
                `endif
                //if (HSSUPPORT && (I_HIGHSPEED == 1)) begin
                //    wait_count <= wait_send_hs;
                //end
                //else begin
                //    wait_count <= wait_send_fs;
                //end
            end
            ST_GOTDATA: begin
                // Wait for inter-packet delay before responding
                if (wait_count == 0) begin
                    // Move to response state
                    if (T_TYPE == 2'd1) begin //Isochronous Transactions do not need ack
                        s_state <= ST_IDLE;
                        s_finished <= 1;
                    end
                    else begin
                        s_state <= ST_SENDSHAKE;
                    end
                    if (T_STALL == 1) begin
                        s_sendpid <= pid_stall;
                    end else if (T_NAK == 1) begin
                        s_sendpid <= pid_nak;
                    end
                    `ifdef HSSUPPORT
                        //else if (HSSUPPORT && (I_HIGHSPEED == 1) && (T_NYET == 1)) begin
                        //    s_sendpid <= pid_nyet;
                        //end
                        else if ((I_HIGHSPEED == 1) && (T_NYET == 1)) begin
                            s_sendpid <= pid_nyet;
                        end
                    `endif
                    else begin
                        s_sendpid <= pid_ack;
                    end
                end
                else begin
                    wait_count <= wait_count - 1;
                end
            end
            ST_SENDDATA: begin
                // Start sending a data packet
                if (P_TXRDY == 1) begin
                    // Sent PID byte, need first data byte
                    s_state <= ST_SENDING;
                end
            end
            ST_SENDING: begin
                // Send payload of data packet
                if (T_SEND == 0) begin
                    // End of data packet; wait for ACK.
                    if (P_RXACT == 1) begin
                        // We are receiving something; probably an echo
                        // of our outgoing packet. Let this stuff pass
                        // before we start waiting for ACK.
                        s_state <= ST_WAITSKIP;
                    end else begin
                        if (T_TYPE == 2'd1) begin //Isochronous Transactions do not need ack
                            s_state <= ST_IDLE;
                            s_finished <= 1;
                        end
                        else begin
                            s_state <= ST_WAITACK;
                        end
                    end
                end
                // Initialize ACK timer.
                `ifdef HSSUPPORT
                    if (I_HIGHSPEED == 1)
                       wait_count <= wait_timeout_hs;
                    else
                       wait_count <= wait_timeout_fs;
                `elsif FSSUPPORT
                       wait_count <= wait_timeout_fs;
                `elsif LSSUPPORT
                       wait_count <= wait_timeout_ls;
                `else
                       wait_count <= wait_timeout_fs;
                `endif
                //if (HSSUPPORT && (I_HIGHSPEED == 1))
                //    wait_count <= wait_timeout_hs;
                //else
                //    wait_count <= wait_timeout_fs;
            end
            ST_WAITACK: begin
                // Wait for ACK handshake
                if (P_RXACT == 1) begin
                    if (P_RXRDY == 1) begin
                        // Got PID byte
                        case (P_RXDAT[3:0])
                            pid_ack: begin
                                // ACK handshake
                                s_state <= ST_GETACK;
                            end
                            pid_out: begin
                                // unexpected OUT token
                                s_in_valid <= 0;
                                s_in    <= 0;
                                s_out   <= 1;
                                s_state <= ST_GETTOKEN1;
                            end
                            pid_in: begin
                                // unexpected IN token
                                s_in    <= 1;
                                s_state <= ST_GETTOKEN1;
                            end
                            pid_setup: begin
                                // unexpected SETUP token
                                s_in_valid <= 0;
                                s_in    <= 0;
                                s_setup <= 1;
                                s_state <= ST_GETTOKEN1;
                            end
                            pid_ping: begin
                                // unexpected PING token
                                `ifdef HSSUPPORT
                                    s_in_valid <= 0;
                                    s_in    <= 0;
                                    s_ping  <= 1;
                                    s_state <= ST_GETTOKEN1;
                                `else
                                    s_state <= ST_SKIP;
                                `endif
                                //if (HSSUPPORT) begin
                                //    s_in    <= 0;
                                //    s_ping  <= 1;
                                //    s_state <= ST_GETTOKEN1;
                                //end    else begin
                                //    // no PINGing for full speed devices
                                //    s_state <= ST_SKIP;
                                //end
                            end
                            default: begin
                                // unexpected packet
                                // This could be our own transmitted packet
                                // (if it was very short), so skip this.
                                s_state <= ST_WAITSKIP;
                            end
                        endcase
                    end
                end else if (s_prevrxact == 1) begin
                        // got bad packet
                        ack_bad_packet_o <= 1'b1;
                        s_state <= ST_IDLE;
                end else if (wait_count == 0) begin
                    // timeout while waiting for ACK
                    ack_timeout_o <= 1'b1;
                    s_state <= ST_IDLE;
                end
                    // count down timer
                    wait_count <= wait_count - 1;
            end
            ST_WAITSKIP: begin
                // Skip the echo of our own transmitted packet
                if (wait_count == 0) begin
                    // timeout
                    s_state <= ST_SKIP;
                end else if (P_RXACT == 0) begin
                    // end of packet
                    if (T_TYPE == 2'd1) begin //Isochronous Transactions do not need ack
                        s_state <= ST_IDLE;
                        s_finished <= 1;
                    end
                    else begin
                        s_state <= ST_WAITACK;
                    end
                end
                // count down timer
                wait_count <= wait_count - 1;
            end
            ST_GETACK: begin
                // Wait for end of incoming ACK packet
                if (P_RXFIN == 1) begin
                    ack_received_o <= 1'b1;
                    // ACK handshake was good
                    s_finished <= 1;
                    s_state <= ST_IDLE;
                end
                else if (P_RXACT == 0) begin
                    // ACK handshake was bad
                    s_state <= ST_IDLE;
                end
            end
        endcase
    end
end

endmodule


/////////////////////////////////////////////////////////////////////////////////////
//
//  USB 2.0 Packet-level logic.
//
//  This entity hides the details of the UTMI interface and handles
//  computation and verificaton of CRCs.
//
//  The low-level interface signals are named PHY_xxx and may be
//  connected to an UTMI compliant USB PHY, such as the SMSC GT3200.
//
//  The application interface signals are named P_xxx.
//  The receiving side of the interface operates as follows:
//    * At the start of an incoming packet, RXACT is set high.
//    * When a new byte arrives, RXRDY is asserted and the byte is put
//      on RXDAT. These signals are valid for only one clock cycle; the
//      application must accept them immediately.
//    * The first byte of a packet is the PID. Subsequent bytes contain
//      data and CRC. This entity verifies the CRC, but does not
//      discard it from the data stream.
//    * Some time after correctly receiving the last byte of a packet,
//      RXACT is deasserted; at the same time RXFIN is asserted for one cycle
//      to confirm the packet.
//    * If a corrupt packet is received, RXACT is deasserted without
//      asserting RXFIN.
//
//  The transmission side of the interface operates as follows:
//    * The application starts transmission by setting TXACT to 1 and setting
//      TXDAT to the PID value (with correctly mirrored high order bits).
//    * The entity asserts TXRDY when it needs the next payload byte.
//      On the following clock cycle, the application must then provide the
//      next payload byte on TXDAT, or deassert TXACT to indicate the end of
//      the packet. The signal on TXDAT must be held stable until the next
//      assertion of TXRDY.
//    * CRC bytes should not be included in the payload; the entity will
//      add them automatically.
//    * As part of the high speed handshake, the application may request
//      transmission of a continuous chirp K state by asserting CHIRPK.
//
//  Implementation note:
//  Transmission timing is a bit tricky due to the following issues:
//    * After the PHY asserts PHY_TXREADY, we must immediately provide
//      new data or deassert PHY_TXVALID on the next clock cycle.
//    * The PHY may assert PHY_TXREADY during subsequent clock cycles,
//      even though the average byte period is more than 40 cycles.
//    * We want to register PHY inputs and outputs to ensure valid timing.
//
//  To satisfy these requirements, we make the application run one byte
//  ahead. While keeping the current byte in the output register PHY_DATAOUT,
//  the application already provides the following data byte. That way, we
//  can respond to PHY_TXREADY immediately in the next cycle, with the
//  application following up in the clock cycle after that.
//
/////////////////////////////////////////////////////////////////////////////////////


//module usb_packet (
module `getname(usb_packet,`module_name) (
    // 60 MHz UTMI clock.
    input wire CLK,

    // Synchronous reset of this entity.
    input wire RESET,

    // High to force chirp K transmission.
    input wire P_CHIRPK,

    // High while receiving a packet.
    output wire P_RXACT,

    // Indicates next byte received; data must be read from RXDAT immediately.
    output wire P_RXRDY,

    // High for one cycle to indicate successful completion of packet.
    output wire P_RXFIN,

    // Received byte value. Valid if RXRDY is high.
    output wire [7 : 0] P_RXDAT,

    // High while transmitting a packet.
    input wire P_TXACT,

    // Request for next data byte; application must change TXDAT on the next clock cycle.
    output wire P_TXRDY,

    // Data byte to transmit. Hold stable until next assertion of TXRDY.
    input wire [7 : 0] P_TXDAT,

    // Connect to UTMI DataIn signal.
    input wire [7 : 0] PHY_DATAIN,

    // Connect to UTMI DataOut signal.
    output reg [7 : 0] PHY_DATAOUT,

    // Connect to UTMI TxValid signal.
    output reg PHY_TXVALID,

    // Connect to UTMI TxReady signal.
    input wire PHY_TXREADY,

    // Connect to UTMI RxActive signal.
    input wire PHY_RXACTIVE,

    // Connect to UTMI RxValid signal.
    input PHY_RXVALID,

    // Connect to UTMI RxError signal.
    input wire PHY_RXERROR
    ,input wire clk_120
    ,output reg [3:0] crc_dbg_dataout_o
);


    // State machine
    //localparam ST_NONE        = 4'h0;
    //localparam ST_CHIRPK    = 4'h1;
    //localparam ST_RWAIT        = 4'h2;
    //localparam ST_RTOKEN    = 4'h3;
    //localparam ST_RDATA        = 4'h4;
    //localparam ST_RSHAKE    = 4'h5;
    //localparam ST_TSTART    = 4'h6;
    //localparam ST_TDATA        = 4'h7;
    //localparam ST_TCRC1        = 4'h8;
    //localparam ST_TCRC2        = 4'h9;
    localparam ST_NONE        = 12'h000;
    localparam ST_CHIRPK    = 12'h001;
    localparam ST_RWAIT        = 12'h002;
    localparam ST_RTOKEN    = 12'h004;
    localparam ST_RDATA        = 12'h008;
    localparam ST_RSHAKE    = 12'h010;
    localparam ST_TSTART    = 12'h020;
    localparam ST_TDATA        = 12'h040;
    localparam ST_TCRC1        = 12'h080;
    localparam ST_TCRC2        = 12'h100;

    //reg [3 : 0] s_state = ST_NONE;
    reg [11 : 0] s_state;
    reg s_txfirst = 1'b0;

    // Registered inputs
    reg s_rxactive;
    reg s_rxvalid;
    reg s_rxerror;
    reg [7 : 0] s_datain;
    reg s_txready;

    // Byte pending for transmission
    reg [7 : 0] s_dataout;

    // True if an incoming packet would be valid if it ended now.
    reg s_rxgoodpacket;

    // CRC computation
    localparam crc5_gen  = 5'b00101;
    localparam crc5_res  = 5'b01100;
    localparam crc16_gen = 16'b1000000000000101;
    localparam crc16_res = 16'b1000000000001101;

    reg [4 : 0] crc5_buf ;
    reg [15 : 0]  crc16_buf;

    //Variables
    reg [7 : 0] v_dataout;
    reg v_txvalid;
    reg v_crc_upd;
    reg [7 : 0] v_crc_data;
    reg [4 : 0] v_crc5_new;
    reg [15 : 0] v_crc16_new;
    //

    integer i;

    // Update CRC 5 to account for a new byte
    function [4 : 0] crc5_upd;
        input  [4 : 0] c;
        input  [7 : 0] b;
        //output [4 : 0] y;

        reg [4 : 0] t;

        begin
             t = {b[0] ^ c[4],
                        b[1] ^ c[3],
                        b[2] ^ c[2],
                        b[3] ^ c[1],
                        b[4] ^ c[0]};

         crc5_upd = {b[5] ^ t[1] ^ t[2],
                        b[6] ^ t[0] ^ t[1] ^ t[4],
                        b[5] ^ b[7] ^ t[0] ^ t[3] ^ t[4],
                        b[6] ^ t[1] ^ t[3] ^ t[4],
                        b[7] ^ t[0] ^ t[2] ^ t[3] };
        end
    endfunction

    // Update CRC-16 to account for new byte
    function [15:0] crc16_upd;
        input  [15 : 0] c;
        input  [ 7 : 0] b;
        //output [15 : 0] y;

        reg [7 : 0] t;

        begin
             t = {b[0] ^ c[15],
                        b[1] ^ c[14],
                        b[2] ^ c[13],
                        b[3] ^ c[12],
                        b[4] ^ c[11],
                        b[5] ^ c[10],
                        b[6] ^ c[9],
                        b[7] ^ c[8] };

             crc16_upd = {c[7] ^ t[0] ^ t[1] ^ t[2] ^ t[3] ^ t[4] ^ t[5] ^ t[6] ^ t[7],
                        c[6], c[5], c[4], c[3], c[2],
                        c[1] ^ t[7],
                        c[0] ^ t[6] ^ t[7],
                        t[5] ^ t[6],
                        t[4] ^ t[5],
                        t[3] ^ t[4],
                        t[2] ^ t[3],
                        t[1] ^ t[2],
                        t[0] ^ t[1],
                        t[1] ^ t[2] ^ t[3] ^ t[4] ^ t[5] ^ t[6] ^ t[7],
                        t[0] ^ t[1] ^ t[2] ^ t[3] ^ t[4] ^ t[5] ^ t[6] ^ t[7] };
        end
    endfunction

    // Assign output signals
    assign P_RXACT = s_rxactive;
    assign P_RXFIN = ~s_rxactive & ~s_rxerror & s_rxgoodpacket;
    assign P_RXRDY = s_rxactive & s_rxvalid;
    assign P_RXDAT = s_datain;

    // Assert P_TXRDY during ST_TSTART to acknowledge the PID byte,
    // during the first cycle of ST_TDATA to acknowledge the first
    // data byte, and whenever we need a new data byte during ST_TDATA.
    assign P_TXRDY = (s_state == ST_TSTART) ? 1'b1 : ((s_state == ST_TDATA)&P_TXACT) ? (s_txfirst | s_txready) : 1'b0;



    //reg [7:0] crc_dbg_dataout_buf0, crc_dbg_dataout_buf1;
    //reg clk60_buf0, clk60_buf1;
    //always @(clk_120) begin

    //    crc_dbg_dataout_buf0 <= v_dataout;
    //    crc_dbg_dataout_buf1 <= crc_dbg_dataout_buf0;

    //    clk60_buf0 <= CLK;
    //    clk60_buf1 <= clk60_buf0;

    //    if (RESET) begin
    //        crc_dbg_dataout_o <= 4'b0;
    //    end else begin
    //        if (s_state >= ST_TSTART) begin
    //            crc_dbg_dataout_o <= (clk60_buf1) ? crc_dbg_dataout_buf1[7:4] : crc_dbg_dataout_buf1[3:0];  
    //        end else begin
    //            crc_dbg_dataout_o <= 4'b0000; //(clk60_buf1) ? 4'b0000 : 4'b0001;  
    //        end
    //    end
    //end




    // On every rising clock edge
    always@(posedge CLK) begin
        // Default assignment to temporary variables
        v_dataout   = s_dataout;
        v_txvalid   = 1'b0;
        v_crc_upd   = 1'b0;
        v_crc_data  = 8'h00;
        v_crc5_new  = 5'h00;
        v_crc16_new = 16'h0000;

        // Default assignment to s_txfirst
        s_txfirst <= 1'b0;

        // Register inputs
        s_rxactive <= PHY_RXACTIVE;
        s_rxvalid  <= PHY_RXVALID;
        s_rxerror  <= PHY_RXERROR;
        s_datain   <= PHY_DATAIN;
        s_txready  <= PHY_TXREADY;

        // State machine
        if(RESET) begin
            // Reset entity
            s_state        <= ST_NONE;
            s_rxgoodpacket <= 1'b0;
        end
        else begin
            case(s_state)
                ST_NONE : begin
                    // Waiting for incoming or outgoing packet
                    // Initialize CRC buffers
                    crc5_buf       <= 5'h1F;
                    crc16_buf      <= 16'hFFFF;
                    s_rxgoodpacket <= 1'b0;
                    if(P_CHIRPK) begin
                        // Send continuous chirp K.
                        s_state <= ST_CHIRPK;
                    end    else if(s_rxactive) begin
                        // Receiver starting
                        if(s_rxerror) begin
                            // Receive error at PHY level
                            s_state <= ST_RWAIT;
                        end    else if(s_rxvalid) begin
                            // Got PID byte
                            if (s_datain[3:0] ==  ~s_datain[7:4]) begin
                                case (s_datain[1:0])
                                    2'b01 : begin // token packet
                                        s_state <= ST_RTOKEN;
                                    end
                                    2'b11 : begin // data packet
                                        s_state <= ST_RDATA;
                                    end
                                    2'b10 : begin // handshake packet
                                        s_state        <= ST_RSHAKE;
                                        s_rxgoodpacket <= 1'b1;
                                    end
                                    default : begin // PING token or special packet
                                        // If this is a PING token, it will work out fine;
                                        // otherwise it will be flagged as a bad packet
                                        // either here or in usb_transact.
                                        s_state <= ST_RTOKEN;
                                    end
                                endcase
                            end    else begin
                                // Corrupt PID byte
                                s_state <= ST_RWAIT;
                            end
                        end
                    end    else if (P_TXACT) begin
                        // Transmission starting; put data in output buffer
                        v_txvalid = 1'b1;
                        v_dataout = P_TXDAT;
                        s_state   <= ST_TSTART;
                    end
                end
/////////////////
                ST_CHIRPK : begin
                    // Sending continuous chirp K.
                    if (!P_CHIRPK) begin
                        s_state <= ST_NONE;
                    end
                end

                ST_RTOKEN : begin
                    // Receiving a token packet
                    if(!s_rxactive) begin
                        // End of packet
                        s_rxgoodpacket <= 1'b0;
                        s_state        <= ST_NONE;
                    end    else if(s_rxerror) begin
                        // Error at PHY level
                        s_rxgoodpacket <= 1'b0;
                        s_state <= ST_RWAIT;
                    end    else if(s_rxvalid) begin
                        // Just received a byte; update CRC
                        v_crc5_new = crc5_upd(crc5_buf, s_datain);
                        crc5_buf   <= v_crc5_new;
                        if(v_crc5_new == crc5_res) begin
                            s_rxgoodpacket <= 1'b1;
                        end    else begin
                            s_rxgoodpacket <= 1'b0;
                        end
                    end
                end

                ST_RDATA : begin
                    // Receiving a data packet
                    if(!s_rxactive) begin
                        // End of packet
                        s_rxgoodpacket <= 1'b0;
                        s_state        <= ST_NONE;
                    end    else if(s_rxerror) begin
                        // Error at PHY level
                        s_rxgoodpacket <= 1'b0;
                        s_state        <= ST_RWAIT;
                    end else if(s_rxvalid) begin
                        // Just received a byte; update CRC
                        v_crc_upd  = 1'b1;
                        v_crc_data = s_datain;
                    end
                end

                ST_RWAIT : begin
                    // Wait until the end of the current packet
                    if (!s_rxactive) begin
                        s_state <= ST_NONE;
                    end
                end

                ST_RSHAKE : begin
                    // Receiving a handshake packet
                    if(!s_rxactive) begin
                        // Got good handshake
                        s_rxgoodpacket <= 1'b0;
                        s_state        <= ST_NONE;
                    end    else if(s_rxerror | s_rxvalid) begin
                        // Error or unexpected data byte in handshake packet
                        s_rxgoodpacket <= 1'b0;
                        s_state        <= ST_RWAIT;
                    end
                end

                ST_TSTART : begin
                    // Transmission starting;
                    // PHY module sees our PHY_TXVALID signal;
                    // PHY_TXREADY is undefined;
                    // we assert P_TXRDY to acknowledge the PID byte
                    v_txvalid = 1'b1;
                    // Check packet type
                    case(P_TXDAT[1:0])
                        2'b11 : begin // data packet
                            s_state   <= ST_TDATA;
                            s_txfirst <= 1'b1;
                        end
                        2'b10 : begin // handshake packet
                            s_state <= ST_RWAIT;
                        end
                        default : begin // should not happen
                        end
                    endcase
                end

                ST_TDATA : begin
                    // Sending a data packet
                    v_txvalid = 1'b1;
                    if(s_txready | s_txfirst) begin
                        // Need next byte
                        if(!P_TXACT) begin
                            // No more data; send first CRC byte
                            for(i=0; i<=7; i=i+1) begin
                                v_dataout[i] = ~crc16_buf[15-i];
                            end
                            s_state <= ST_TCRC1;
                        end    else begin
                            // Put next byte in output buffer
                            v_dataout = P_TXDAT;
                            // And update the CRC
                            v_crc_upd  = 1'b1;
                            v_crc_data = P_TXDAT;
                        end
                    end
                end

                ST_TCRC1 : begin
                    // Sending the first CRC byte of a data packet
                    v_txvalid = 1'b1;
                    if(s_txready) begin
                        // Just queued the first CRC byte; move to 2nd byte
                        for(i=0; i<=7; i=i+1) begin
                            v_dataout[i] = ~crc16_buf[7-i];
                        end
                        s_state <= ST_TCRC2;
                    end
                end

                ST_TCRC2 : begin
                    // Sending the second CRC byte of a data packet
                    if(s_txready) begin
                        // Just sent the 2nd CRC byte; end packet
                        s_state <= ST_RWAIT;
                    end
                    else begin
                        // Last byte is still pending
                        v_txvalid = 1'b1;
                    end
                end

            endcase
        end

        // CRC-16 update
        if(v_crc_upd) begin
            v_crc16_new = crc16_upd(crc16_buf, v_crc_data);
            crc16_buf   <= v_crc16_new;
            if(s_state == ST_RDATA && v_crc16_new == crc16_res) begin
                // If this is the last byte of the packet, it is a valid packet.
                s_rxgoodpacket <= 1'b1;
            end    else begin
                s_rxgoodpacket <= 1'b0;
            end
        end

        // Drive data output to PHY
        if(RESET) begin
            // Reset.
            PHY_TXVALID <= 1'b0;
            PHY_DATAOUT <= 8'h00;
        end    else if(s_state == ST_CHIRPK) begin
            // Continuous chirp-K.
            PHY_TXVALID <= P_CHIRPK;
            PHY_DATAOUT <= 8'h00;
        end    else if((PHY_TXREADY==1'b1) || (s_state == ST_NONE && P_TXACT == 1'b1)) begin
            // Move a data byte from the buffer to the output lines when the PHY
            // accepts the previous byte, and also at the start of a new packet.
            PHY_TXVALID <= v_txvalid;
            PHY_DATAOUT <= v_dataout;
        end

        // Keep pending output byte in register.
        s_dataout <= v_dataout;
    end

endmodule




`timescale 1ns / 1ps
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  USB 2.0 Default control endpoint
//
//  This entity implements the minimal required functionality of
//  the default control endpoint.
//
//  The low-level interface signals are named T_xxx and should be conditionally
//  connected to the usb_transact interface in the following way:
//    * Always connect output signal C_ADDR to T_ADDR;
//    * Always connect input signals T_FIN, T_OSYNC, T_RXRDY, T_RXDAT, T_TXRDY;
//    * If T_ENDPT = 0, connect input signals T_IN, T_OUT, T_SETUP, T_PING;
//      otherwise pull these inputs to zero.
//    * If T_ENDPT = 0, connect output signals T_NAK, T_STALL, T_NYET, T_SEND,
//      T_ISYNC, T_TXDAT; otherwise another endpoint should drive these.
//    * If T_ENDPT = 0 and C_DSCBUSY = 0, connect output signal T_TXDAT;
//      otherwise if T_ENDPT = 0 and C_DSCBUSY = 1, drive T_TXDAT
//      from descriptor memory;
//      otherwise another endpoint drives T_TXDAT.
//
//  A device descriptor and a configuration descriptor must be provided
//  in external memory. If high speed mode is supported, an other-speed
//  device qualifier and other-speed configuration descriptor must also
//  be provided. In addition, string descriptors may optionally be provided.
//  Each descriptor may be at most 255 bytes long.
//  A maximum packet size of 64 bytes is assumed for control transfers.
//
//  This entity uses the following protocol to access descriptor data:
//    * When C_DSCBUSY is high, the entity is accessing descriptor data.
//      A descriptor is selected by signals C_DSCTYP and C_DSCINX;
//      a byte within this descriptor is selected by signal C_DSCOFF.
//    * Based on C_DSCTYP and C_DSCINX, the application must assign
//      the length of the selected descriptor to C_DSCLEN. If the selected
//      descriptor does not exist, the application must set C_DSCLEN to zero.
//      C_DSCLEN must be valid one clock after rising C_DSCBUSY and must
//      remain stable as long as C_DSCBUSY, C_DSCTYP and C_DSCINX remain
//      unchanged.
//    * When C_DSCRD is asserted, the application must put the selected
//      byte from the selected descriptor on T_TXDAT towards usb_transact.
//      The application must respond in the first clock cycle following
//      assertion of C_DSCRD.
//    * When C_DSCRD is not asserted, but C_DSCBUSY is still high,
//      the application must keep T_TXDAT unchanged. Changes to C_DSCOFF
//      must not affect T_TXDAT while C_DSCRD is low.
//
//  The standard device requests are handled as follows:
//
//    Clear Feature:
//      When clearing the ENDPOINT_HALT feature, reset the endpoint's
//      sync bits (as required by spec). Otherwise ignore but report
//      success status.
//      BAD: should return STALL when referring to invalid endpoint/interface.
//
//    Get Configuration:
//      Return 1 if configured, 0 if not configured.
//
//    Get Descriptor:
//      Handled by application through descriptor data interface as
//      described above.
//
//    Get Interface:
//      Always return zero byte.
//      BAD: should return STALL when referring to invalid endpoint/interface.
//
//    Get Status:
//      Return device status / endpoint status / zero.
//      BAD: should return STALL when referring to invalid endpoint/interface.
//
//    Set Address:
//      Store new address.
//
//    Set Configuration:
//      Switch between Configured and Address states; clear all endpoint
//      sync bits (as required by spec). Accepts only configuration values
//      0 and 1.
//
//    Set Descriptor:
//      Not implemented; returns STALL. (Correct; request is optional.)
//
//    Set Feature:
//      Only ENDPOINT_HALT feature implemented; otherwise returns STALL.
//      BAD: every high speed device must support TEST_MODE.
//
//    Set Interface:
//      Not implemented; returns STALL.
//      (Correct; request is optional if no interfaces have alternate settings.)
//
//    Synch Frame:
//      Not implemented; returns STALL.
//      (Correct, assuming no isosynchronous endpoints.)
//
//  Non-standard requests are silently ignored but return success status.
//  This is incorrect, but necessary to get host software to accept usb_serial
//  as CDC-ACM device.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////


//module usb_control #(
module `getname(usb_control,`module_name) #(
    // Highest endpoint number in use.
    parameter NENDPT = 4'h0
)(
    // 60 MHz UTMI clock.
    input wire CLK,

    // Synchronous reset of this entity.
    input wire RESET,

    `ifdef HSSUPPORT
    // Test mode select.
    output wire [7 : 0] C_TESTMODE,
    output wire         C_TEST_EN,
    `endif

    // Current device address.
    output wire [6 : 0] C_ADDR,

    // High when in Configured state.
    output wire C_CONFD,

    // Trigger clearing of sync/halt bits for IN endpoint.
    output reg [1 : NENDPT] C_CLRIN,

    // Trigger clearing of sync/halt bits for OUT endpoint.
    output reg [1 : NENDPT] C_CLROUT,

     // Current status of halt bit for IN endpoints.
    input wire [1 : NENDPT] C_HLTIN,

    // Current status of halt bit for IN endpoints.
    input wire [1 : NENDPT] C_HLTOUT,

    // Trigger setting of halt bit for IN endpoints.
    output reg [1 : NENDPT] C_SHLTIN,

    // Trigger setting of halt bit for OUT endpoints.
    output reg [1 : NENDPT] C_SHLTOUT,

    input      [7 : 0] C_INTERFACE_ALTER_I,
    output     [7 : 0] C_INTERFACE_ALTER_O,
    output     [7 : 0] C_INTERFACE,
    output             C_INTERFACE_UPDATE,
    // High when accessing descriptor memory.
    // Note that C_DSCBUSY may go low in between packets of a single descriptor.
    output wire C_DSCBUSY,

    // Descriptor read enable. Asserted to request a descriptor byte;
    // in the next clock cycle, the application must update T_TXDAT.
    output wire C_DSCRD,

    // LSB bits of the requested descriptor type. Valid when C_DSCBUSY is high.
    output wire [7 : 0] C_DSCTYP,

    // Requested descriptor index. Valid when C_DSCBUSY is high.
    output wire [7 : 0] C_DSCINX,

    // Offset within requested descriptor. Valid when C_DSCBUSY and C_DSCRD are high.
    output wire [15 : 0] C_DSCOFF,

    // Set to length of current descriptor by application.
    input wire [15 : 0] C_DSCLEN,

    // High if the device is not drawing bus power.
    input wire C_SELFPOWERED,

    // Connect to T_IN from usb_transact when T_ENDPT = 0, otherwise pull to 0.
    input wire T_IN,

    // Connect to T_OUT from usb_transact when T_ENDPT = 0, otherwise pull to 0.
    input wire T_OUT,

    // Connect to T_SETUP from usb_transact when T_ENDPT = 0, otherwise pull to 0.
    input wire T_SETUP,

    // Connect to T_PING from usb_transact when T_ENDPT = 0, otherwise pull to 0.
    input wire T_PING,

    // Connect to T_FIN from ubs_transact.
    input wire T_FIN,

    // Connect to T_NAK towards usb_transact when T_ENDPT = 0.
    output wire T_NAK,

    // Connect to T_STALL towards usb_transact when T_ENDPT = 0.
    output wire T_STALL,

    // Connect to T_NYET towards usb_transact when T_ENDPT = 0.
    output wire T_NYET,

    // Connect to T_SEND towards usb_transact when T_ENDPT = 0.
    output wire T_SEND,

    // Connect to T_ISYNC towards usb_transact when T_ENDPT = 0.
    output wire T_ISYNC,

    // Connect to T_OSYNC from usb_transact.
    input wire T_OSYNC,

    // Connect to T_RXRDY from usb_transact.
    input wire T_RXRDY,

    // Connect to T_RXDAT from usb_transact.
    input wire [7 : 0] T_RXDAT,

    // Connect to T_TXRDY from usb_transact.
    input wire T_TXRDY,

    // Connect to T_TXDAT towards usb_transact when T_ENDPT = 0 and C_DSCBUSY = '0'.
    output wire [7 : 0] T_TXDAT
);



    // Constants for control request
    localparam req_getstatus    = 4'b0000;
    localparam req_clearfeature = 4'b0001;
    localparam req_setfeature   = 4'b0011;
    localparam req_setaddress   = 4'b0101;
    localparam req_getdesc      = 4'b0110;
    localparam req_getconf      = 4'b1000;
    localparam req_setconf      = 4'b1001;
    localparam req_getiface     = 4'b1010;
    localparam req_setinterface = 4'b1011;

    // State machine
    //localparam ST_IDLE            = 4'h0;
    //localparam ST_STALL            = 4'h1;
    //localparam ST_SETUP            = 4'h2;
    //localparam ST_SETUPERR        = 4'h3;
    //localparam ST_NONSTANDARD    = 4'h4;
    //localparam ST_ENDSETUP        = 4'h5;
    //localparam ST_WAITIN        = 4'h6;
    //localparam ST_SENDRESP        = 4'h7;
    //localparam ST_STARTDESC        = 4'h8;
    //localparam ST_SENDDESC        = 4'h9;
    //localparam ST_DONESEND        = 4'hA;
    localparam ST_IDLE            = 12'h000;
    localparam ST_STALL           = 12'h001;
    localparam ST_SETUP           = 12'h002;
    localparam ST_SETUPERR        = 12'h004;
    localparam ST_NONSTANDARD     = 12'h008;
    localparam ST_ENDSETUP        = 12'h010;
    localparam ST_WAITIN          = 12'h020;
    localparam ST_SENDRESP        = 12'h040;
    localparam ST_STARTDESC       = 12'h080;
    localparam ST_SENDDESC        = 12'h100;
    localparam ST_DONESEND        = 12'h200;

    //reg [3 : 0] s_state = ST_IDLE;
    reg [11 : 0] s_state = ST_IDLE;


    // Current control request
    reg [ 3:0] s_ctlrequest;
    reg [ 7:0] s_ctlparam;
    reg [ 7:0] s_desctyp;
    reg [15:0] s_answerlen;
    reg [ 7:0] s_sendbyte = 'h0;

    reg [ 7:0] s_interface_alter;
    reg [ 7:0] s_interface;
    reg        s_interface_set;

    // Device state
    reg [ 6:0] s_addr  = 'h0;
    reg        s_confd = 'b0;

    // Counters
    reg [ 2:0] s_setupptr;
    reg [15:0] s_answerptr;
    reg        s_nak;



   assign C_INTERFACE_ALTER_O  = s_interface_alter;
   assign C_INTERFACE          = s_interface;
   assign C_INTERFACE_UPDATE  = s_interface_set;


    // Status signals
    assign C_ADDR  = s_addr;
    assign C_CONFD = s_confd;

    // Memory interface
    assign C_DSCBUSY = (s_state == ST_WAITIN) ? T_IN : (s_state == ST_STARTDESC || s_state == ST_SENDDESC) ? 1'b1 : 1'b0;
    assign C_DSCRD   = (s_state == ST_STARTDESC) ? 1'b1 : T_TXRDY;
    assign C_DSCTYP  = s_desctyp;
    assign C_DSCINX  = s_ctlparam;
    assign C_DSCOFF  = s_answerptr;

    // Transaction interface
    assign T_NAK   = 1'b0;
    assign T_STALL = (s_state == ST_STALL) ? 1'b1 : 1'b0;
    assign T_NYET  = 1'b0;
    assign T_SEND  = ((s_state == ST_SENDRESP) || (s_state == ST_SENDDESC)) ? 1'b1 : 1'b0;
    `ifdef DESC_PACKET_MAX8
        assign T_ISYNC = ~s_answerptr[3];
    `elsif DESC_PACKET_MAX16
        assign T_ISYNC = ~s_answerptr[4];
    `elsif DESC_PACKET_MAX32
        assign T_ISYNC = ~s_answerptr[5];
    `elsif DESC_PACKET_MAX64
        assign T_ISYNC = ~s_answerptr[6];
    `else
        assign T_ISYNC = ~s_answerptr[3];
    `endif
    assign T_TXDAT = s_sendbyte;

integer i;
//generate

`ifdef HSSUPPORT
assign C_TESTMODE = s_testmode;
assign C_TEST_EN = s_test_en;
reg [7:0] s_testmode;
reg       s_test_en;
reg       s_test_sel;
`endif
    // On every rising clock edge
    always@(posedge CLK) begin

        // State machine
        if(RESET) begin
            //Reset this entity
            s_state <= ST_IDLE;
            s_addr  <= 'h0;
            s_confd <= 'b0;
        `ifdef HSSUPPORT
            s_testmode <= 'd0;
            s_test_en <= 1'b0;
            s_test_sel <= 1'b0;
        `endif
            //Trigger endpoint reset lines
            C_CLRIN  <= ~0;
            C_CLROUT <= ~0;
            C_SHLTIN  <= 'h0;
            C_SHLTOUT <= 'h0;
            s_interface_alter <= 'd0;
            s_interface <= 'd0;
            s_interface_set <= 'd0;
        end
        else begin
            case(s_state)
                ST_IDLE : begin
                    // Idle; wait for SETUP transaction;
                    // OUT transactions are ignored but acknowledged;
                    // IN transactions send an empty packet.
                    s_answerptr <= 'h0;
                    s_interface_set <= 'd0;
                    if(T_SETUP == 1'b1) begin
                        // Start of SETUP transaction
                        s_state <= ST_SETUP;
                        s_setupptr <= 'h0;
                        //Set endpoint reset/halt lines to zero by default
                        C_CLRIN   <= 'h0;
                        C_CLROUT  <= 'h0;
                        C_SHLTIN  <= 'h0;
                        C_SHLTOUT <= 'h0;
                    end
                end

                ST_STALL : begin
                    // Stalled; wait for next SETUP transaction;
                    // respond to IN/OUT transactions with a STALL handshake.
                    if(T_SETUP == 1'b1) begin
                        // Start of SETUP transaction
                        s_state <= ST_SETUP;
                        s_setupptr <= 'h0;
                    end
                end

                ST_SETUP : begin
                    //In SETUP transaction; parse request structure.
                    s_answerptr <= 'h0;
                    if (T_RXRDY == 1'b1) begin
                        // Process next request byte
                        case (s_setupptr)
                            3'b000 : begin
                                //bmRequestType
                                s_ctlparam <= T_RXDAT;
                                if (T_RXDAT[6:5] != 2'b00) begin
                                    //non-standard device request
                                    s_state <= ST_NONSTANDARD;
                                end
                            end

                            3'b001 : begin
                                //bRequest
                                s_ctlrequest <= T_RXDAT[3:0];
                                if (T_RXDAT[7:4] != 4'b0000) begin
                                    //Unknown request
                                    s_state <= ST_SETUPERR;
                                end
                            end

                            3'b010 : begin
                                // wValue lsb
                                if(s_ctlrequest != req_getstatus) begin
                                    s_ctlparam <= T_RXDAT;
                                    s_interface_alter <= T_RXDAT;
                                end
                            end

                            3'b011 : begin
                                //wValue msb
                                //if (s_ctlrequest == req_getdesc) begin
                                //    if(T_RXDAT[7:3] != 5'b00000) begin//only support 0~7
                                //        //Unsupported descriptor type
                                //        s_state <= ST_SETUPERR;
                                //    end
                                //end
                                //Store descriptor type (assuming GET_DESCRIPTOR request)
                                //s_desctyp <= T_RXDAT[2:0];
                                s_desctyp <= T_RXDAT[7:0];
                            end

                            3'b100 : begin
                                //wIndex lsb
                                case (s_ctlrequest)
                                    req_clearfeature : begin
                                        if (s_ctlparam == 8'h0) begin
                                            //Clear ENDPOINT_HALT feature;
                                            //store endpoint selector
                                            s_ctlparam <= T_RXDAT;
                                        end
                                        else begin
                                            //Unknown clear feature request
                                            s_ctlparam <= 0;
                                        end
                                    end
                                    req_setfeature : begin
                                        if(s_ctlparam == 8'h0) begin
                                            //Set ENDPOINT_HALT feature;
                                            //store endpoint selector
                                            s_ctlparam <= T_RXDAT;
                                        end
                                        `ifdef HSSUPPORT
                                        else if(s_ctlparam == 8'h2) begin
                                            //Set TEST_MODE feature;
                                            //store TEST_MODE selector
                                            s_test_sel <= 1'b1;
                                        end
                                        `endif
                                        else begin
                                            //Unsupported set feature request
                                            s_state <= ST_SETUPERR;
                                        end
                                    end
                                    req_getiface : begin
                                        s_interface <= T_RXDAT;
                                    end
                                    req_setinterface : begin
                                        s_interface <= T_RXDAT;
                                    end
                                    req_getstatus : begin
                                        if(s_ctlparam[1:0] == 2'b00) begin
                                            //Get device status
                                            s_sendbyte <= {7'h0, C_SELFPOWERED};
                                            s_ctlparam <= 8'h0;
                                        end
                                        else if(s_ctlparam[1:0] == 2'b10) begin
                                            //Get endpoint status
                                            s_sendbyte <= 8'h0;
                                            s_ctlparam <= T_RXDAT;
                                        end
                                        else begin
                                            //Probably get interface status
                                            s_sendbyte <= 8'h0;
                                            s_ctlparam <= 8'h0;
                                        end
                                    end
                                    default : begin
                                        //Don't care about index.
                                    end
                                endcase
                            end

                            3'b101 : begin
                                //wIndex msb; don't care
                                `ifdef HSSUPPORT
                                if (s_ctlrequest == req_setfeature) begin
                                    if (s_test_sel) begin
                                        s_ctlparam <= T_RXDAT;
                                    end
                                end
                                `endif
                            end

                            3'b110 : begin
                                //wLength lsb
                                s_answerlen[7:0] <= T_RXDAT;
                            end

                            3'b111 : begin
                                //wLength msb
                                //if (T_RXDAT != 8'h0) begin
                                //    s_answerlen <= {8{1'b1}};
                                //end
                                s_answerlen[15:8] <= T_RXDAT;
                                s_state <= ST_ENDSETUP;
                            end

                            default : begin
                                //Impossible
                            end
                        endcase

                        //Increment position within SETUP packet
                        s_setupptr <= s_setupptr + 1;
                    end
                    else if(T_FIN == 1'b1) begin
                        //Got short SETUP packet; answer with STALL status.
                        s_state <= ST_STALL;
                    end
                    else if(T_SETUP == 1'b0) begin
                        //Got corrupt SETUP packet; ignore.
                        s_state <= ST_IDLE;
                    end
                end

                ST_SETUPERR : begin
                    //In SETUP transaction; got request error
                    if(T_FIN == 1'b1) begin
                        //Got good SETUP packet that causes request error
                        s_state <= ST_STALL;
                    end
                    else if(T_SETUP == 1'b0) begin
                        //Got corrupt SETUP packet; ignore
                        s_state <= ST_IDLE;
                    end
                end

                ST_NONSTANDARD : begin
                    //Ignore non-standard requests
                    if(T_SETUP == 1'b0) begin
                        s_state <= ST_IDLE;
                    end
                end

                ST_ENDSETUP : begin
                    //Parsed request packet; wait for end of SETUP transaction
                    if(T_FIN == 1'b1) begin
                        //Got complet SETUP packet; handle it
                        case (s_ctlrequest)
                            req_getstatus : begin
                                //Prepare status byte and move to data stage
                                //If s_ctlparam = 0, the status byte has already
                                //been prepared in state S_SETUP.
                                /*
                                for(i=1; i<=NENDPT; i=i+1) begin
                                    if(s_ctlparam[3:0] == i) begin
                                        if(s_ctlparam[7] == 1'b1) begin
                                            s_sendbyte <= {7'h0, C_HLTIN[i]};
                                        end
                                        else begin
                                            s_sendbyte <= {7'h0, C_HLTOUT[i]};
                                        end
                                    end
                                end
                                */
                               case (s_ctlparam[3:0])
                                   4'd1: begin
                                       if (NENDPT >= 1) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[1]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[1]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd2: begin
                                       if (NENDPT >= 2) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[2]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[2]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd3: begin
                                       if (NENDPT >= 3) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[3]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[3]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd4: begin
                                       if (NENDPT >= 4) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[4]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[4]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd5: begin
                                       if (NENDPT >= 5) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[5]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[5]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd6: begin
                                       if (NENDPT >= 6) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[6]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[6]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd7: begin
                                       if (NENDPT >= 7) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[7]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[7]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd8: begin
                                       if (NENDPT >= 8) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[8]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[8]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd9: begin
                                       if (NENDPT >= 9) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[9]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[9]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd10: begin
                                       if (NENDPT >= 10) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[10]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[10]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd11: begin
                                       if (NENDPT >= 11) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[11]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[11]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd12: begin
                                       if (NENDPT >= 12) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[12]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[12]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd13: begin
                                       if (NENDPT >= 13) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[13]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[13]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd14: begin
                                       if (NENDPT >= 14) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[14]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[14]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   4'd15: begin
                                       if (NENDPT >= 15) begin
                                           if(s_ctlparam[7] == 1'b1) begin
                                               s_sendbyte <= {7'h0, C_HLTIN[15]};
                                           end
                                           else begin
                                               s_sendbyte <= {7'h0, C_HLTOUT[15]};
                                           end
                                       end
                                       else begin
                                           s_sendbyte <= 8'd0;
                                       end
                                   end
                                   default : s_sendbyte <= s_sendbyte;//this it get device status
                               endcase
                               s_state <= ST_WAITIN;
                            end

                            req_clearfeature : begin
                                //Reset endpoint
                                for(i=1; i<=NENDPT; i=i+1) begin
                                    if(s_ctlparam[3:0] == i) begin
                                        if(s_ctlparam[7] == 1'b1) begin
                                            C_CLRIN[i] <= 1'b1;
                                        end
                                        else begin
                                            C_CLROUT[i] <= 1'b1;
                                        end
                                    end
                                end
                                s_state <= ST_IDLE;
                            end

                            req_setfeature : begin
                            `ifdef HSSUPPORT
                                if (!s_test_sel) begin //Set endpoint HALT
                            `endif
                                    for(i=1; i<=NENDPT; i=i+1) begin
                                        if(s_ctlparam[3:0] == i) begin
                                            if(s_ctlparam[7] == 1'b1) begin
                                                C_SHLTIN[i] <= 1'b1;
                                            end
                                            else begin
                                                C_SHLTOUT[i] <= 1'b1;
                                            end
                                        end
                                    end
                                    s_state <= ST_IDLE;
                             `ifdef HSSUPPORT
                                end
                                else begin//Set test mode
                                    s_testmode <= s_ctlparam;
                                    s_state <= ST_WAITIN;
                                end
                             `endif

                            end
                            req_setinterface : begin
                                s_interface_set <= 1'b1;
                            end

                            req_setaddress : begin
                                //Move to status stage
                                s_state <= ST_WAITIN;
                            end

                            req_getdesc : begin
                                //Move to data stage
                                s_state <= ST_WAITIN;
                            end

                            req_getconf : begin
                                //Move to data stage
                                s_state <= ST_WAITIN;
                            end

                            req_setconf : begin
                                //Set device configuration
                                if(s_ctlparam[7:1] == 7'h0) begin
                                    s_confd  <= s_ctlparam[0];
                                    s_state  <= ST_IDLE;
                                    C_CLRIN  <= ~0;
                                    C_CLROUT <= ~0;
                                end
                                else begin
                                    //Unknown configuration number
                                    s_state <= ST_STALL;
                                end
                            end
                            req_setinterface : begin
                                // Move to data stage
                                s_state <= ST_IDLE;
                            end

                            req_getiface : begin
                                //Move to data stage
                                s_state <= ST_WAITIN;
                            end

                            default : begin
                                //Unsupported request
                                s_state <= ST_STALL;
                            end
                        endcase
                    end
                    else if(T_SETUP == 1'b0) begin
                        //Got corrupt SETUP packet; ignore
                        s_state <= ST_IDLE;
                    end
                end

                ST_WAITIN : begin
                    //Got valid SETUP packet; waiting for IN transaction.
                    `ifdef DESC_PACKET_MAX8
                        s_answerptr[2:0] <= 3'd0;
                    `elsif DESC_PACKET_MAX16
                        s_answerptr[3:0] <= 4'd0;
                    `elsif DESC_PACKET_MAX32
                        s_answerptr[4:0] <= 5'd0;
                    `elsif DESC_PACKET_MAX64
                        s_answerptr[5:0] <= 6'd0;
                    `else
                        s_answerptr[2:0] <= 3'd0;
                    `endif
                    if(T_SETUP == 1'b1) begin
                        //Start of next SETUP transaction
                        s_state    <= ST_SETUP;
                        s_setupptr <= 'h0;
                    end
                    else if(T_IN == 1'b1) begin
                        //Start of IN transaction; respond to the request
                        case(s_ctlrequest)
                            req_getstatus : begin
                                //Respond with status byte, followed by zero byte.
                                s_state <= ST_SENDRESP;
                            end

                            req_setaddress : begin
                                //Effectuate change of device address
                                s_addr  <= s_ctlparam[6:0];
                                s_state <= ST_IDLE;
                            end

                            req_getdesc : begin
                                //Respond with descriptor
                                s_state <= ST_STARTDESC;
                            end

                            req_getconf : begin
                                //Respond with current configuration
                                s_sendbyte <= {7'h0, s_confd};
                                s_state <= ST_SENDRESP;
                            end

                            req_getiface : begin
                                //Respond with zero byte
                                s_sendbyte <= C_INTERFACE_ALTER_I;
                                s_state <= ST_SENDRESP;
                            end
                            req_setfeature : begin
			                  `ifdef HSSUPPORT
                                if (s_test_sel) begin //Set test mode
                                    s_test_en <= 1'b1;
                                end
                                else
                              `endif
                                    s_state <= ST_STALL;
                            end

                            default : begin
                                //Impossible
                            end
                        endcase
                    end
                end

                ST_SENDRESP : begin
                    //Respond to IN with a preset byte,
                    //followed by zero or more nul byte(s)
                    if(T_IN == 1'b0) begin
                        //Aborted IN transaction; wait for retry
                        s_state <= ST_WAITIN;
                    end
                    else if(T_TXRDY == 1'b1) begin
                        //Need next data byte
                        s_sendbyte <= 8'h0;
                        if(s_answerptr[0] | s_answerlen[0]) begin
                            //Reached end of transfer.
                            //Note that we only ever send 1 or 2 byte answers.
                            s_state <= ST_DONESEND;
                        end
                        `ifdef DESC_PACKET_MAX8
                            s_answerptr[2:0] <= s_answerptr[2:0] + 1'b1;
                        `elsif DESC_PACKET_MAX16
                            s_answerptr[3:0] <= s_answerptr[3:0] + 1'b1;
                        `elsif DESC_PACKET_MAX32
                            s_answerptr[4:0] <= s_answerptr[4:0] + 1'b1;
                        `elsif DESC_PACKET_MAX64
                            s_answerptr[5:0] <= s_answerptr[5:0] + 1'b1;
                        `else
                            s_answerptr[2:0] <= s_answerptr[2:0] + 1'b1;
                        `endif
                    end
                end

                ST_STARTDESC : begin
                    //Fetching first byte of packet.
                    if(T_IN == 1'b0) begin
                        //Aborted IN transaction; wait for retry
                        s_state <= ST_WAITIN;
                    end
                    else if(C_DSCLEN == 'h0) begin
                        //Invalid descriptor.
                        s_state <= ST_STALL;
                    end
                    else if((s_answerptr == C_DSCLEN) || (s_answerptr == s_answerlen)) begin
                        //Send an empty packet to complete the transfer.
                        s_state <= ST_DONESEND;
                    end
                    else begin
                        //Send a normal descriptor packet.
                        s_state <= ST_SENDDESC;
                    end
                    `ifdef DESC_PACKET_MAX8
                        s_answerptr[2:0] <= s_answerptr[2:0] + 1'b1;
                    `elsif DESC_PACKET_MAX16
                        s_answerptr[3:0] <= s_answerptr[3:0] + 1'b1;
                    `elsif DESC_PACKET_MAX32
                        s_answerptr[4:0] <= s_answerptr[4:0] + 1'b1;
                    `elsif DESC_PACKET_MAX64
                        s_answerptr[5:0] <= s_answerptr[5:0] + 1'b1;
                    `else
                        s_answerptr[2:0] <= s_answerptr[2:0] + 1'b1;
                    `endif
                end

                ST_SENDDESC : begin
                    //Respond to IN with descriptor
                    if(T_IN == 1'b0) begin
                        //Aborted IN transaction; wait for retry
                        s_state <= ST_WAITIN;
                    end    else if(T_TXRDY == 1'b1) begin
                        //Need next data byte
                        `ifdef DESC_PACKET_MAX8
                            if((s_answerptr[2:0] == 0) || (s_answerptr == C_DSCLEN) || (s_answerptr == s_answerlen)) begin
                        `elsif DESC_PACKET_MAX16
                            if((s_answerptr[3:0] == 0) || (s_answerptr == C_DSCLEN) || (s_answerptr == s_answerlen)) begin
                        `elsif DESC_PACKET_MAX32
                            if((s_answerptr[4:0] == 0) || (s_answerptr == C_DSCLEN) || (s_answerptr == s_answerlen)) begin
                        `elsif DESC_PACKET_MAX64
                            if((s_answerptr[5:0] == 0) || (s_answerptr == C_DSCLEN) || (s_answerptr == s_answerlen)) begin
                        `else
                            if((s_answerptr[2:0] == 0) || (s_answerptr == C_DSCLEN) || (s_answerptr == s_answerlen)) begin
                        `endif
                            //Just sent the last byte of the packet
                            s_state <= ST_DONESEND;
                        end
                        else begin
                            `ifdef DESC_PACKET_MAX8
                                s_answerptr[2:0] <= s_answerptr[2:0] + 1'b1;
                            `elsif DESC_PACKET_MAX16
                                s_answerptr[3:0] <= s_answerptr[3:0] + 1'b1;
                            `elsif DESC_PACKET_MAX32
                                s_answerptr[4:0] <= s_answerptr[4:0] + 1'b1;
                            `elsif DESC_PACKET_MAX64
                                s_answerptr[5:0] <= s_answerptr[5:0] + 1'b1;
                            `else
                                s_answerptr[2:0] <= s_answerptr[2:0] + 1'b1;
                            `endif
                        end
                    end
                end

                ST_DONESEND : begin
                    //Done sending packet; wait until IN transaction completes.
                    //Note: s_answerptr contains the number of bytes sent so-far,
                    //unless this is a multiple of 64, in which case s_answerptr
                    //contains 64 less than the number of bytes sent; and unless
                    //the last packet sent was an empty end-of-transfer packet,
                    //in which case s_answerptr contains 1 more than the number
                    //of bytes sent.
                    if(T_FIN == 1'b1) begin
                        //Host acknowledged transaction.
                        `ifdef DESC_PACKET_MAX8
                            if(s_answerptr[2:0] == 0) begin
                        `elsif DESC_PACKET_MAX16
                            if(s_answerptr[3:0] == 0) begin
                        `elsif DESC_PACKET_MAX32
                            if(s_answerptr[4:0] == 0) begin
                        `elsif DESC_PACKET_MAX64
                            if(s_answerptr[5:0] == 0) begin
                        `else
                            if(s_answerptr[2:0] == 0) begin
                        `endif
                            //The last sent packet was a full sized packet.
                            //If s_answerptr + 64 = s_answerlen, the transfer
                            //is now complete; otherwise the host will expect
                            //more data. In either case, we go back to WAITIN.
                            //This can't go wrong because WAITIN also listens
                            //for the next SETUP and handles it properly.
                            s_state <= ST_WAITIN;
                        end    else begin
                            //The last sent packet was not full sized;
                            //it was either empty or reached the end of
                            //the descriptor. In either case, the transfer
                            //is now complete.
                            s_state <= ST_IDLE;
                        end
                        `ifdef DESC_PACKET_MAX8
                            s_answerptr <= s_answerptr + 8;
                        `elsif DESC_PACKET_MAX16
                            s_answerptr <= s_answerptr + 16;
                        `elsif DESC_PACKET_MAX32
                            s_answerptr <= s_answerptr + 32;
                        `elsif DESC_PACKET_MAX64
                            s_answerptr <= s_answerptr + 64;
                        `else
                            s_answerptr <= s_answerptr + 8;
                        `endif
                    end    else if(T_IN == 1'b0) begin
                        //Transaction failed; wait for retry.
                        s_state <= ST_WAITIN;
                    end
                end
            endcase
        end
    end
//endgenerate
endmodule

//module test_packet
module `getname(test_packet,`module_name)
(
    input              clk_i        ,//clock
    input              reset_i      ,//reset
    input              test_en_i    ,//
    input  [7:0]       test_mode_i  ,//
    input              tx_rdy_i     ,//
    output             test_en_dly_o,//
    output             test_dval_o  ,//
    output [7:0]       test_data_o   //
);

//==============================================================
//======Test Packet Inter-Packet Gap Should Less Than 125us And Geater Than 32 Bits
localparam INTER_GAP = 120; //600 CLK about 10us
reg [11:0] cnt;
reg [7:0] test_data;
reg       test_data_val;
reg       test_en_dly;
reg       test_en_dect;
assign test_en_dly_o = test_en_dly;
always @(posedge clk_i or posedge reset_i) begin
    if (reset_i) begin
        test_en_dect <= 1'b0;
    end
    else if (test_en_i) begin
        test_en_dect <= 1'b1;
    end
end
always @(posedge clk_i or posedge reset_i) begin
    if (reset_i) begin
        cnt <= 12'd0;
        test_en_dly <= 1'b0;
    end
    else begin
        if (test_en_dly) begin
            if (test_mode_i==8'h04) begin
                if (cnt >= INTER_GAP) begin
                    cnt <= 12'd0;
                end
                else begin
                    if (cnt < 12'd55) begin
                        if (tx_rdy_i) begin
                            cnt <= cnt + 12'd1;
                        end
                    end
                    else begin
                        cnt <= cnt + 12'd1;
                    end
                end
            end
        end
        else begin
            if (test_en_dect) begin
                if (cnt >= 12'd3125) begin
                    cnt <= 12'd0;
                    test_en_dly <= 1'b1;
                end
                else begin
                    cnt <= cnt + 12'd1;
                end
            end
            else begin
                cnt <= 12'd0;
            end
        end
    end
end

//==============================================================
//======Test Packets
assign test_dval_o  = test_data_val;
assign test_data_o = test_data;
always @(posedge clk_i or posedge reset_i) begin
    if (reset_i) begin
        test_data <= 8'd0;
        test_data_val <= 1'b0;
    end
    else begin
        if (test_en_dly) begin
            if (cnt == 12'd0) begin //0xC3
                if (tx_rdy_i) begin
                    test_data <= 8'h00;
                end
                else begin
                    test_data <= 8'hC3;
                end
                test_data_val <= 1'b1;
            end
            else if (cnt < 12'd9) begin //9*0x00
                test_data <= 8'h00;
                test_data_val <= 1'b1;
            end
            else if (cnt < 12'd17) begin //8*0xA5
                test_data <= 8'hAA;
                test_data_val <= 1'b1;
            end
            else if (cnt < 12'd25) begin //8*0xEE
                test_data <= 8'hEE;
                test_data_val <= 1'b1;
            end
            else if (cnt == 12'd25) begin //8*0xEE
                test_data <= 8'hFE;
                test_data_val <= 1'b1;
            end
            else if (cnt < 12'd37) begin //{111111*15},111111-->12*0xFF
                test_data <= 8'hFF;
                test_data_val <= 1'b1;
            end
            else if (cnt < 12'd45) begin //111111,{0111111*7},0-->
                if (tx_rdy_i) begin
                    case (cnt[2:0])
                        3'd5 : test_data <= 8'b01111111;
                        3'd6 : test_data <= 8'b10111111;
                        3'd7 : test_data <= 8'b11011111;
                        3'd0 : test_data <= 8'b11101111;
                        3'd1 : test_data <= 8'b11110111;
                        3'd2 : test_data <= 8'b11111011;
                        3'd3 : test_data <= 8'b11111101;
                        3'd4 : test_data <= 8'b11111100;
                    endcase
                end
            end
            else if (cnt < 12'd53) begin //111111,{0111111*7},0-->
                if (tx_rdy_i) begin
                    case (cnt[2:0])
                        3'd5 : test_data <= 8'b01111110;
                        3'd6 : test_data <= 8'b10111111;
                        3'd7 : test_data <= 8'b11011111;
                        3'd0 : test_data <= 8'b11101111;
                        3'd1 : test_data <= 8'b11110111;
                        3'd2 : test_data <= 8'b11111011;
                        3'd3 : test_data <= 8'b11111101;
                        3'd4 : test_data <= 8'b01111110;
                    endcase
                end
            end
            else if (cnt < 12'd54) begin //CRC16 B6
                test_data <= 8'hB6;
                test_data_val <= 1'b1;
            end
            else if (cnt < 12'd55) begin //CRC16 CE
                test_data <= 8'hCE;
                test_data_val <= 1'b1;
            end
            else begin
                if (tx_rdy_i) begin
                    test_data <= 8'h00;
                    test_data_val <= 1'b0;
                end
            end
        end
        else begin
            test_data <= 8'd0;
            test_data_val <= 1'b0;
        end
    end
end
endmodule
